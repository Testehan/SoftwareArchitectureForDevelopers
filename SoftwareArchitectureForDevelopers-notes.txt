Software architecture plays a pivotal role in the delivery of successful software yet it’s frustratingly neglected by many
teams. Whether performed by one person or shared amongst the team,
the software architecture role exists on even the most agile of teams yet the balance of up front
and evolutionary thinking often reflects aspiration rather than reality.

What’s all this old-fashioned software architecture stuff anyway? Many software teams seem
to think that they don’t need software architects, throwing around terms like “self-organising
team”, “YAGNI” (you aren’t going to need it), “evolutionary architecture” and “last responsible
moment” instead. If they do need an architect, they’ll probably be on the lookout for an “agile
architect”. I’m not entirely sure what this term actually means, but I assume that it has something
to do with using post-it notes instead of UML or doing TDD (test-driven development) instead
of drawing pictures

Such irresponsible architects are usually tasked with being the technical leader
yet fail to cover the basics. I’ve seen public facing websites go into a user acceptance testing
environment with a number of basic security problems, a lack of basic performance testing,
basic functionality problems, broken hyperlinks and a complete lack of documentation. And
that was just my external view of the software, who knows what the code looked like. If you’re
undertaking the software architecture role and you’re delivering stuff like this, you’re doing it
wrong. This isn’t software architecture, it’s also foolishly hoping for the best.


This book is a practical, pragmatic and lightweight guide to software architecture for developers.
You’ll learn:
    • The essence of software architecture.
    • Why the software architecture role should include coding, coaching and collaboration.
    • The things that you really need to think about before coding.
    • How to visualise your software architecture using simple sketches.
    • A lightweight approach to documenting your software.
    • Why there is no conflict between agile and architecture.
    • What “just enough” up front design means.
    • How to identify risks with risk-storming.


Why did I write the book?
    1. Software architecture needs to be more accessible: Despite having some fantastic
    mentors, I didn’t find it easy to understand what was expected of me when I was moving
    into my first software architecture roles. Sure, there are lots of software architecture books
    out there, but they seem to be written from a different perspective. I found most of them
    very research oriented or academic in nature, yet I was a software developer looking for
    real-world advice. I wanted to write the type of book that I would have found useful at
    that stage in my career - a book about software architecture aimed at software developers

    2. All software projects need software architecture: I like agile approaches, I really do, but
    the lack of explicit regard for software architecture in many of the approaches doesn’t sit
    well with me. Agile approaches don’t say that you shouldn’t do any up front design, but
    they often don’t explicitly talk about it either. I’ve found that this causes people to jump to
    the wrong conclusion and I’ve seen the consequences that a lack of any up front thinking
    can have. I also fully appreciate that big design up front isn’t the answer either. I’ve
    always felt that there’s a happy medium to be found where some up front thinking is done,
    particularly when working with a team that has a mix of experiences and backgrounds. I
    favour a lightweight approach to software architecture that allows me to putsome building
    blocks in place as early as possible, to stack the odds of success in my favour.

    3. Lightweight software architecture practices: I’ve learnt and evolved a number of
    practices over the years, which I’ve always felt have helped me to perform the software
    architecture role. These relate to the software design process and identifying technical risks
    through to communicating and documenting software architecture. I’ve always assumed
    that these practices are just common sense, but I’ve discovered that this isn’t the case. I’ve
    taught these practices to thousands of people over the past few years and I’ve seen the
    difference they can make. A book helps me to spread these ideas further, with the hope
    that other people will find them useful too


Five things every developer should know about software architecture
    1. Software architecture isn’t about big design up front
    Software architecture has traditionally been associated with big design up front and waterfallstyle projects, where
    a team would ensure that every last element of the software design was
    considered before any code was written. Software architecture is basically about the high-level
    structure of a software system and how you get to an understanding of it. This is about the
    significant decisions that influence the shape of a software system rather than understanding
    how long every column in the database should be.

    2. Every software team needs to consider software architecture
    Regardless of the size and complexity of the resulting product, every software team needs to
    consider software architecture. Why? Put simply, bad things tend to happen if they don’t! If
    software architecture is about structure and vision, not thinking about this tends to lead to poorly
    structured, internally inconsistent software systems that are hard to understand, hard to maintain
    and potentially don’t satisfy one or more of the important non-functional requirements such as
    performance, scalability or security. Explicitly thinking about software architecture provides you
    with a way to introduce technical leadership and stacks the odds of a successful delivery in your
    favour.

    3. The software architecture role is about coding, coaching and collaboration
    The image that many people have of software architects is of traditional “ivory tower” software
    architects dictating instructions to an unsuspecting development team. It doesn’t need to be
    like this though, with modern software architects preferring an approach that favours coding,
    coaching and collaborative design. The software architecture role doesn’t necessarily need to be
    undertaken by a single person plus coding is a great way to understand whether the resulting
    architecture is actually going to work.

    4. You don’t need to use UML
    Again, traditional views of software architecture often conjure up images of huge UML (Unified
    Modeling Language) models that attempt to capture every last drop of detail. While creating and
    communicating a common vision is important, you don’t need to use UML. In fact, you could
    argue that UML isn’t a great method for communicating software architecture anyway. If you
    keep a few simple guidelines in mind, lightweight “boxes and lines” style sketches are an effective
    way to communicate software architecture.

    5. A good software architecture enables agility
    There’s a common misconception that “architecture” and “agile” are competing forces, there
    being a conflict between them. This simply isn’t the case though. On the contrary, a good
    software architecture enables agility, helping you embrace and implement change. Good
    software architectures aren’t created by themselves though, and some conscious effort is needed.


===============================================================================================================
===============================================================================================================
Part 1 - What is software architecture?

    In this part of the book we’ll look at what software architecture is about, the difference between
    architecture and design, what it means for an architecture to be agile and why thinking about
    software architecture is important.

    What is architecture?
        architecture as a noun and architecture as a verb, with both being applicable regardless of
        whether we’re talking about constructing a physical building or a software system.

 !!!!   As a noun = architecture can be summarised as being about structure. It’s about the
        decomposition of a product into a collection of components/modules and interactions. This needs
        to take into account the whole of the product, including the foundations and infrastructure
        services that deal with cross-cutting concerns such as power/water/air conditioning (for a
        building) or security/configuration/error handling (for a piece of software)

 !!!!   As a verb = architecture (i.e. the process, architecting) is about understanding what you need to
        build, creating a vision for building it and making the appropriate design decisions. All of this
        needs to be based upon requirements because requirements drive architecture. Crucially, it’s
        also about communicating that vision and introducing technical leadership so that everybody
        involved with the construction of the product understands the vision and is able to contribute in
        a positive way to its success.

        Regardless of whether you’re building a software system, a network or a database; a successful
        solution requires you to understand the problem and create a vision that can be communicated
        to everybody involved with the construction of the end-product. Architecture, regardless of the
        domain, is about structure and vision.


    What is software architecture?
        At first glance, “software architecture” seems like an easy thing to define. It’s about the
        architecture of a piece of software, right? Well, yes, but it’s about more than just software.

!!!!    Application architecture
            Application architecture is what we as software developers are probably most familiar with,
            especially if you think of an “application” as typically being written in a single technology
            (e.g. a Java web application, a desktop application on Windows, etc). It puts the application
            in focus and normally includes things such as decomposing the application into its constituent
            classes and components, making sure design patterns are used in the right way, building or
            using frameworks, etc. In essence, application architecture is inherently about the lower-level
            aspects of software design and is usually only concerned with a single technology stack (e.g.
            Java, Microsoft .NET, etc).
            The building blocks are predominantly software based and include things like programming
            languages and constructs, libraries, frameworks, APIs, etc. It’s described in terms of classes,
            components, modules, functions, design patterns, etc. Application architecture is predominantly
            about software and the organisation of the code.

!!!!    System architecture
            I like to think of system architecture as one step up in scale from application architecture. If
            you look at most software systems, they’re actually composed of multiple applications across a
            number of different tiers and technologies. As an example, you might have a software system
            comprised of a .NET Silverlight client accessing web services on a Java EE middle-tier, which
            itself consumes data from an Oracle database. Each of these will have their own application
            architecture.

            For the overall software system to function, thought needs to be put into bringing all of those
            separate applications together. In other words, you also have the overall structure of the end-toend software
            system at a high-level. Additionally, most software systems don’t live in isolation,
            so system architecture also includes the concerns around interoperability and integration with
            other systems within the environment.

            Compared to application architecture, system architecture is described in terms of higher levels of abstraction; from
            components and services through to sub-systems. Most definitions of system architecture include
            references to software and hardware. After all, you can’t have a successful software system
            without hardware, even if that hardware is virtualised somewhere out there on the cloud.

        Software architecture
            Unlike application and system architecture, which are relatively well understood, the term
            “software architecture” has many different meanings to many different people. Rather than
            getting tied up in the complexities and nuances of the many definitions of software architecture,
            I like to keep the definition as simple as possible.
!!!!        For me, software architecture is simply the combination of application and system architecture

            In other words, it’s anything and everything related to the significant elements of a software
            system; from the structure and foundations of the code through to the successful deployment of
            that code into a live environment.

!!          When we’re thinking about software development as software
            developers, most of our focus is placed on the code. Here, we’re thinking about things like object
            oriented principles, classes, interfaces, inversion of control, refactoring, automated unit testing,
            clean code and the countless other technical practices that help us build better software.

            If your team consists of people who are only thinking about this, then who is thinking about the other
            stuff?
                • Cross-cutting concerns such as logging and exception handling.
                • Security; including authentication, authorisation and confidentiality of sensitive data.
                • Performance, scalability, availability and other quality attributes.
                • Audit and other regulatory requirements.
                • Real-world constraints of the environment.
                • Interoperability/integration with other software systems.
                • Operational, support and maintenance requirements.
                • Consistency of structure and approach to solving problems/implementing features across the codebase.
                • Evaluating that the foundations you’re building will allow you to deliver what you set out to deliver.

        Enterprise architecture - strategy rather than code
            It looks at how to organise and utilise people, process and technology to make
            an organisation work effectively and efficiently. In other words, it’s about how an enterprise
            is broken up into groups/departments, how business processes are layered on top and how
            technology underpins everything. This is in very stark contrast to software architecture because
            it doesn’t necessarily look at technology in any detail.
            Enterprise architecture requires a higher level of abstraction. It’s about breadth rather than depth and
            strategy rather than code.


    What is agile software architecture?
        labelling a software architecture as being “agile”
        means that it can react to change within its environment, adapting to the ever changing
        requirements that people throw at it. This isn’t necessarily the same as the software architecture
        that an agile team will create. Delivering software in an agile way doesn’t guarantee that the
        resulting software architecture will be agile. In fact, in my experience, the opposite typically
        happens because teams are more focussed on delivering functionality rather than looking after
        their architecture

        John Boyd, a fighter pilot in the US Air Force, came up with a concept
        that he called the OODA loop² - Observe, Orient, Decide and Act. In essence, this loop forms
        the basis for the decision making process. Imagine that you are a fighter pilot in a dogfight with
        an adversary. In order to outwit your opponent in this situation, you need to observe what’s
        happening, orient yourself (e.g. do some analysis), decide what to do and then act. In the heat
        of the battle, this loop needs to be executed as fast as possible to avoid being shot down by your
        opponent. Boyd then says that you can confuse and disorient your opponent if you can get inside
        their OODA loop, by which he means execute it faster than they can. If you’re more agile than
        your opponent, you’re the one that will come out on top.

!!!!    there’s a growing trend of software
        systems being made up of tiny micro-services⁵, where each service only does one thing but does
        that thing very well. A micro-service may typically be less than one hundred lines of code. If
        change is needed, services can be rewritten from scratch, potentially in a different programming
        language. This style of architecture provides agility in a number of ways. Small, loosely coupled
        components/services can be built, modified and tested in isolation, or even ripped out and
        replaced depending on how requirements change. This style of architecture also lends itself well
        to a very flexible and adaptable deployment model, since new components/services can be added
        and scaled if needed.

        Understanding the speed at which your organisation or business changes is important because
        it can help you decide upon the style of architecture to adopt; whether that’s a monolithic
        architecture, a micro-services architecture or something in between. You need to understand
        the trade-offs and make your choices accordingly. You don’t get agility for free.


    Architecture vs design
        Grady Booch has a well cited definition of the difference between architecture and design that
        really helps to answer this question. In On Design¹, he says that
            As a noun, design is the named (although sometimes unnameable) structure or
            behavior of an system whose presence resolves or contributes to the resolution of
            a force or forces on that system. A design thus represents one point in a potential
            decision space.

        If you think about any problem that you’ve needed to solve, there are probably a hundred and one
        ways in which you could have solved it. Take your current software project for example. There
        are probably a number of different technologies, deployment platforms and design approaches
        that are also viable options for achieving the same goal. In designing your software system
        though, your team chose just one of the many points in the potential decision space.
        Grady then goes on to say that…
            All architecture is design but not all design is architecture.

        This makes sense because creating a solution is essentially a design exercise. However, for some
        reason, there’s a distinction being made about not all design being “architecture”, which he
        clarifies with the following statement.
            Architecture represents the significant design decisions that shape a system, where
            significance is measured by cost of change.
        Essentially, he’s saying that the significant decisions are “architecture” and that everything else
        is “design”. In the real world, the distinction between architecture and design isn’t as clear-cut,
        but this definition does provide us with a basis to think about what might be significant (i.e.
        “architectural”) in our own software systems

    Understanding significance
        It’s often worth taking a step back and considering what’s significant with your own software
        system. For example, many teams use a relational database, the choice of which might be deemed
        as significant. In order to reduce the amount of rework required in the event of a change in
        database technology, many teams use an object-relational mapping (ORM) framework such
        as Hibernate or Entity Framework. Introducing this additional ORM layer allows the database
        access to be decoupled from other parts of the code and, in theory, the database can be switched
        out independently without a large amount of effort.

        This decision to introduce additional layers is a classic technique for decoupling distinct parts of a
        software system; promoting looser coupling, higher cohesion and a better separation of concerns.
        Additionally, with the ORM in place, the choice of database can probably be switched in an
        afternoon, so from this perspective it may no longer be deemed as architecturally significant.

        Although you can’t necessarily make “significant decisions” disappear entirely, you can use
        a number of different tactics such as architectural layering to change what those significant
        decisions are.
!!!!!   Part of the process of architecting a software system is about understanding what is significant and why.


    Is software architecture important?
        Successful software projects aren’t just about good code and sometimes you need to step
        away from the code for a few moments to see the bigger picture.

        it’s easy to see how not thinking about software architecture (and the “bigger picture”) can lead to a number of
        common problems that software teams face on a regular basis. Ask yourself the following questions:
        • Does your software system have a well defined structure?
        • Is everybody on the team implementing features in a consistent way?
        • Is there a consistent level of quality across the codebase?
        • Is there a shared vision for how the software will be built across the team?
        • Does everybody on the team have the necessary amount of technical guidance?
        • Is there an appropriate amount of technical leadership?

    The benefits of software architecture
        What benefits can thinking about software architecture provide then? In summary:
        • A clear vision and roadmap for the team to follow, regardless of whether that vision is
        owned by a single person or collectively by the whole team.
        • Technical leadership and better coordination.
        • A stimulus to talk to people in order to answer questions relating to significant decisions,
        non-functional requirements, constraints and other cross-cutting concerns.
        • A framework for identifying and mitigating risk.
        • Consistency of approach and standards, leading to a well structured codebase.
        • A set of firm foundations for the product being built.
        • A structure with which to communicate the solution at different levels of abstraction to
        different audiences.


===============================================================================================================
===============================================================================================================
Part 2 - The software architecture role
    including what it is, what sort of skills you need and why coding, coaching and collaboration are important.

    The software architecture role
!!      Becoming a software architect isn’t something that simply happens overnight or with a
        promotion. It’s a role, not a rank. It’s the result of an evolutionary process where you’ll gradually
        gain the experience and confidence that you need to undertake the role. While the term “software
        developer” is fairly well understood, “software architect” isn’t.
!!      Notice that I said “role” here; it’s something that can be performed by a single person or shared amongst the team.

        Here are the things that I consider to make up the software architecture role:
            1. Architectural Drivers
!!!             The first part of the role is about understanding the business goals and managing the architectural drivers,
                which includes the requirements (both functional and non-functional) and the
                constraints of the environment. Software projects often get caught up on asking users what
                features they want, but rarely ask them what non-functional requirements (or quality attributes)
                that they need.
                Non-functional requirements and constraints often have a huge influence on
                the software architecture, so explicitly including them as a part of the software architecture role
                helps to ensure that they are considered and taken into account.

            2. Designing Software
                This is about understanding how you’re going to solve the problems posed by
                the architectural drivers, creating the overall structure of the software system and a vision for
                the delivery. Despite how agile you strive to be, you probably do need some time to explicitly
                think about how your architecture is going to solve the problems set out by the stakeholders
                because your software system isn’t going to do this itself.

!!!             A key part of designing software is technology selection, which is typically a fun exercise but
                it does have its fair set of challenges. For example, some organisations have a list of approved
                technologies that you are forced to choose from, while others have rules in place that don’t allow
                open source technology with a specific licence to be used. Then you have all of the other factors
                such as cost, licensing, vendor relationships, technology strategy, compatibility, interoperability,
                support, deployment, upgrade policies, end-user environments and so on. The sum of these
                factors can often make a simple decision of choosing something like a rich client technology into
                a complete nightmare.

            3. Technical Risks
                What we’ve looked at so far will help you focus on building a good solution, but it doesn’t
                guarantee success. Simply throwing together the best designs and the best technologies doesn’t
                necessary mean that the overall architecture will be successful

                Technology selection is all about managing risk; reducing risk where there is high complexity
                or uncertainty and introducing risk where there are benefits to be had
                All technology decisions need to be made by taking all factors into account, and all technology decisions
                need to be reviewed and evaluated. This potentially includes all of the major building blocks for a software
                project right down to the libraries and frameworks being introduced during the development.

                For me, an architecture works if it satisfies the non-functional requirements, works within the given
                environmental constraints, provides the necessary foundations for the rest of the code and works
                as the platform for solving the underlying business problem

 !!!            Furthermore, I don’t always trust myself to get it right first time. Your mileage may vary though!

 !!!            Throughout the software development life cycle, we undertake a number of different types of
                testing in order to give us confidence that the system we are building will work when delivered.
                So why don’t we do the same for our architecture? If we can test our architecture, we can prove
                that it works. And if we can do this as early as possible, we can reduce the overall risk of project
                failure. Like good chefs, architects should taste what they are producing. In a nutshell, this is
                about proactively identifying, mitigating and owning the high priority technical risks so that
                your project doesn’t get cancelled and you don’t get fired.

            4. Architecture Evolution
                More often than not, software is designed and then the baton is passed over to a development
                team, effectively treating software development as a relay sport. This is counterproductive
                because the resulting software architecture needs to be taken care of.
     !!!        If an architect has created an architecture, why shouldn’t they own and evolve
                that architecture throughout the rest of the delivery too? This is about continuous technical
                leadership rather than simply being involved at the start of the life cycle and hoping for the best

            5. Coding
                Most of the best software architects I know have a software development background, but for
                some reason many organisations don’t see this as a part of the software architecture role.

                Many software architects are master builders, so it makes sense to keep those skills up to
                date. In addition, coding provides a way for the architect(s) to share the software development
                experience with the rest of the team, which in turn helps them better understand how the
                architecture is viewed from a development perspective.

                But, generally speaking, a software architect who codes is a more effective and happier architect. You
                shouldn’t necessarily rule out coding just because “you’re an architect”.

            6. Quality Assurance
                Quality assurance should be a part of the software architecture role, but
                it’s more than just doing code reviews. You need a baseline to assure against, which could mean
                the introduction of standards and working practices such as coding standards, design principles
                and tools. Quality assurance also includes ensuring that the architecture is being implemented
                consistently across the team

        Collaborate or fail
            It’s unusual for a software system to reside in isolation and there are a number of people that
            probably need to contribute to the overall architecture process. This ranges from the immediate
            development team who need to understand and buy in to the architecture, right through to the
            extended team of those people who will have an interest in the architecture from a security,
            database, operations, maintenance or support point of view. Anybody undertaking the software
            architecture role needs to collaborate with these people to ensure that the architecture will
            successfully integrate with its environment. If you don’t collaborate, expect to fail.

        Technical leadership is a role, not a rank
            Often large organisations use the job title of “Architect” as a reward for long service or because
            somebody wants a salary increase. And that’s fine if the person on the receiving end of the title
            is capable of undertaking the role but this isn’t always the case. If you’ve ever subscribed to
            software architecture discussion groups on LinkedIn or Stack Overflow, you might have seen
            questions like this:
                "Hi, I’ve just been promoted to be a software architect but I’m not sure what I should
                be doing. Help! Which books should I read?"

        Create your own definition of the role
!!!         Although the need for thinking about software architecture is usually acknowledged, the
            responsibilities of the software architecture role often aren’t clear. In my experience, this can
            lead to a situation where there is nobody undertaking the role, or where somebody is assigned
            the role but doesn’t really understand how they should undertake it. If the role isn’t understood,
            it’s not going to get done and we have little hope of growing the software architects of tomorrow

            Regardless of what you call it (e.g. Architect, Tech Lead, Principal Designer, etc), my advice is
            simple. If you don’t have something that you can point at and say, “this is what we expect of our
            software architects”, take some time to create something. Start by agreeing what is expected of the
            software architecture role on your team and then move to standardise it across your organisation
            if you see benefit in doing so


     Should software architects code?
        In my ideal view of the world, software architects should
        code. Somebody once told me that the key characteristic of a good architect is the ability to think
        in an abstract way. You can also think of it as the ability to not get caught up in the details all of
        the time. That’s fine, but those boxes and lines that you’re drawing do need to be coded at some point.

        Writing code
            My recommendation is to make coding a part of your role as a software architect. You can do this
            by simply being an integral part of the software development team. In other words, you have a
            software architecture hat and a coding hat. You don’t need to be the best coder on the team, but
            the benefits of being hands-on and engaged in the delivery process are huge. After all, there’s a
            difference between “knowing” and “doing”.

        Building prototypes, frameworks and foundations
            One of the problems with being promoted to
            or assigned as a software architect is that you might find that you can’t code as much as you’d
            like to. This may be down to time pressures because you have a lot of “architecture” work to do

            If this is the case, building prototypes and proof of concepts related to the software system in
            question is a great way to be involved. Again, this allows you to build some rapport with the
            team and it’s a great way to evaluate that your architecture will work.

        Performing code reviews
            getting involved with (or doing) the code reviews is one way to at least
            keep your mind fresh with technology and how it’s being used

        Experimenting and keeping up to date
            Often you’ll have more scope outside of work to maintain your coding skills; from contributing to
            an open source project through to continuously playing with the latest language/framework/API
            that takes your fancy. Books, blogs, podcasts, conferences and meetups will get you so far, but
            sometimes you just have to break out the code


    Software architects should be master builders

        Back in time
            If you trace the word “architect” back to its roots in Latin (architectus) and Greek (arkhitekton),
            it basically translates to “chief builder” and, as indicated by the name, these people were masters
            of their craft. In medieval times, the term “architect” was used to signify those people who were
            “master masons”, where “mason” refers to stonemasons because that’s what the majority of the
            buildings were constructed from at the time

        Ivory towers?
            many people see the software architecture role as an elevated position/rank within
            their organisation, which further exaggerates the disconnect between developer and architect

        Divergence of the master builder role
            should software architects write code? My short answer is “ideally, yes” and the longer answer can be
            found here. Why? Because technology isn’t an implementation detail and you need to understand
            the trade-offs of the decisions you are making.

!!          In essence, the traditional architect role has diverged into two roles. One is the structural
            engineer, who ensures that the building doesn’t fall over. And the other is the architect, who
            interacts with the client to gather their requirements and design the building from an aesthetic perspective.

            By comparison, the software development industry
            is still relatively young and moves at an alarmingly fast pace. Buildings today are mostly built
            using the same materials as they were hundreds of years ago, but it seems like we’re inventing a
            new technology every twenty minutes. We live in the era of “Internet time”. Until our industry
            reaches the point where software can be built in the same way as a predictive engineering project,
            it’s crucial that somebody on the team keeps up to date with technology and is able to make the
            right decisions about how to design software.
!!!!        In other words, software architects still need to play the role of structural engineer and architect.

        Achieving the role
            This mirrors my own personal experience of moving into a software architecture role. It was an
            evolutionary process. Like many people, I started my career writing code under the supervision
            of somebody else and gradually, as I gained more experience, started to take on larger and larger
            design tasks. Unlike the medieval building industry though, the software development industry
            lacks an explicit way for people to progress from being junior developers through to software
            architects. We don’t have a common apprenticeship model.

        Architects need to work with the teams
!!!         Performing a software architecture role across a number of teams is not an effective way to work
            though. Typically this situation occurs when there is a centralised group of architects (e.g. in an
            “Enterprise Architecture Group”) who are treated as shared resources. From what I’ve read, the
            master masons were dedicated to a single building site at any one point in time and this is exactly
            the approach that we should adopt within our software development teams.

!!!             A mason would have an apprentice working for him. When the mason moved on
                to a new job, the apprentice would move with him. When a mason felt that his
                apprentice had learned enough about the trade, he would be examined at a Mason’s Lodge.
            Again, it comes back to the strong apprenticeship model in place and this is exactly why coaching
            and mentoring should be a part of the modern software architecture role. We need to grow the
            software architects of tomorrow and every software development team needs their own master builder.


    From developer to architect
        Software architecture is all about having a holistic view and seeing the “big picture” to understand how the
        software system works as a whole.

        While this may help to differentiate software design and architecture, it doesn’t necessarily help
        in understanding how a software developer moves into a software architecture role. Furthermore,
        it also doesn’t help in identifying who will make a good software architect and how you go about
        finding them if you’re hiring.

        Experience is a good gauge but you need to look deeper
            Since the role of a software architect is varied though, you need to look deeper to understand the level
            of involvement, influence, leadership and responsibility that has been demonstrated across a
            number of different areas.
            In conjunction with my definition of the software architecture role, each of the parts can and should be
            evaluated independently.

!!!         the software architecture role undertaken by somebody can vary wildly. For example:
                1. Architectural drivers: capturing and challenging a set of complex non-functional requirements versus
                simply assuming their existence.
                2. Designing software: designing a software system from scratch versus extending an existing one.
                3. Technical risks: proving that your architecture will work versus hoping for the best.
                4. Architecture evolution: being continually engaged and evolving your architecture versus
                choosing to hand it off to an “implementation team”.
                5. Coding: being involved in the hands-on elements of the delivery versus watching from the sidelines.
                6. Quality assurance: assuring quality and selecting standards versus being reviewed against
                them or doing nothing.

        The line is blurred
            people’s level of experience across the software architecture role varies considerably. Furthermore, the line
            between software development and software architecture is blurred somewhat.


    Broadening the T
        Drawing a handful of boxes, lines and clouds on a whiteboard and handing that off as a “software design” is not
        what the role is all about.

        Deep technology skills
            “T” is for technology, and this is exactly what good software architects need to know about.
            As software developers, we tend to have knowledge about things like programming language
            syntax, APIs, frameworks, design patterns, automated unit testing and all of the other low-level
            technical stuff that we use on a daily basis. And this is the same basic knowledge that software
            architects need too. Why? Because people in the software architecture role need to understand
            technology, basically so that they are able to honestly answer the following types of questions:
                • Is this solution going to work?
                • Is that how we are going to build it?

!!!!!   Breadth of knowledge
            it’s important for software architects to have a breadth of technology knowledge too. Sure, they may be
            specialists in Java or Oracle, but the role demands more. For example, the people in the software architecture
            role should be able to answer the following types of questions too:
                • Is the technology that we’ve chosen the most appropriate given the other options available?
                • What are the other options for the design and build of this system?
                • Is there a common architectural pattern that we should be using?
                • Do we understand the trade-offs of the decisions that we’re making?
                • Have we catered for the desired quality attributes?
                • How can we prove that this architecture will work?

        Software architects are generalising specialists
            Most of the best software architects I know have come from a software development background.
            This doesn’t mean that they are the best coders on a team, but they are able to switch between
            the low-level details and the big picture

!!!!        Does this mean that the software architect should be an expert in all of the technologies that are in use on
            any give software system? No.
            Instead collaboration is key. Find somebody that does understand the things you don’t and work with them closely.
            Nothing says that the software architecture role can’t be shared, and often appreciating the gaps
            in your own knowledge is the first step to creating a more collaborative working environment.
 !!         Pair programming has benefits, so why not pair architecting?


    Soft skills
            The majority of the discussion about the software architecture role in this book relates back to
            having technical depth and breadth. But this is really only half the story. Since we’re essentially
            talking about a leadership role, “soft skills” or “people skills” are vitally important too.
            ( I added just some of them)

            • Leadership: In it’s simplest form, leadership is the ability to create a shared vision and to
            then take people on a journey to satisfy the common goal.
            • Communication: You can have the best ideas and vision in the world, but you’re dead in
            the water if you’re unable to effectively communicate this to others. This means people
            inside and outside of the software development team, using the language and level of detail
            that is appropriate to the audience.
            • Collaboration: The software architecture role shouldn’t be done in isolation, and collaboration (working
            with others) to come up with a better solution is a skill that is worth
            practicing. This means listening, being open-minded and responsive to feedback.
            • Coaching: Not everybody will have experience in what you’re trying to do and you’ll
            need to coach people on their role, technologies, etc.
            • Mentoring: Mentoring is about facilitating somebody’s learning rather than telling them
            how to do something. As a leader you may be asked to mentor others on the team.
            • Responsibility: You can’t necessarily blame the rest of the software development team
            for failure and it’s important that you have a sense of responsibility. It’s your problem if
            your software architecture doesn’t satisfy the business goals, deliver the non-functional
            requirements or the technical quality is poor
            • Delegation: Delegation is an important part of any leadership role and there’s a fine line
            between delegating everything and doing everything yourself. You should learn to delegate
            where appropriate but remember that it’s not the responsibility you’re delegating.

 !!!        We don’t often talk about the softer side of being a software architect but the soft skills are
            sometimes more important than being technically strong. A happy team is a team that delivers.
            As a leader, it’s your responsibility to keep the team positive and your role in the overall team
            dynamics shouldn’t be underplayed.

    Software development is not a relay sport
        “Solution Architects”
            There are a lot of people out there, particularly in larger organisations, calling themselves
            “solution architects” or “technical architects”, who design software and document their solutions
            before throwing them over the wall to a separate development team. With the solution “done”,
            the architect will then move on to do the same somewhere else, often not even taking a cursory
            glimpse at how the development team is progressing. When you throw “not invented here”
            syndrome into the mix, there’s often a tendency for that receiving team to not take ownership
            of the solution and the “architecture” initially created becomes detached from reality.

        Somebody needs to own the big picture
            A successful software project requires the initial vision to be created, communicated and
            potentially evolved throughout the entirety of the software development life cycle. For this
            reason alone, it doesn’t make sense for one person to create that vision and for another team to
            (try to) deliver it. When this does happen, the set of initial design artefacts is essentially a baton
            that gets passed between the architect and the development team. This is inefficient, ineffective
            and exchange of a document means that much of the decision making context associated with
            creating the vision is also lost. Let’s hope that the development team never needs to ask any
            questions about the design or its intent!

            Software development is not a relay sport and successful delivery is not an “implementation
            detail”.


    Software architecture introduces control?
        Software architecture introduces structure and vision into software projects but is it also about
        introducing control? And if so, is control a good thing or a bad thing?

        Provide guidance, strive for consistency
            Many of the practices associated with software architecture are about the introduction of
            guidance and consistency into software projects. If you’ve ever seen software systems where a
            common problem or cross-cutting concern has been implemented in a number of different ways,
            then you’ll appreciate why this is important.

            You can’t have people writing database
            access code in your web pages if you’ve specifically designed a distributed software system in
            order to satisfy some of your key non-functional requirements. Control can also be about simply
            ensuring a clear and consistent structure for your codebase; appropriately organising your code
            into packages, namespaces, components, layers, etc.

        How much control do you need?
            The real question to be answered here relates to the amount of control that needs to be introduced.
            At one end of the scale you have the dictatorial approach where nobody can make a decision for
            themselves versus the other end of the scale where nobody is getting any guidance whatsoever

       A lever, not a button
            I like to think of control as being a control lever rather than something binary that is either
            on or off. At one extreme you have the full-throttle dictatorial approach and at the other
            you have something much more lightweight.

            It’s a consulting style answer admittedly, but without knowing your context, it
            depends on a number of things:
                • Are the team experienced?
                • Has the team worked together before?
                • How large is the team?
                • How large is the project?
                • Are the project requirements complex?
                • Are there complex non-functional requirements or constraints that need to be taken into account?
                • What sort of discussions are happening on a daily basis?
                • Does the team or the resulting codebase seem chaotic already?

 !!!!!      My advice would be to start with some control and listen to the feedback in order to fine-tune
            it as you progress. If the team are asking lots of “why?” and “how?” questions, then perhaps
            more guidance is needed. If it feels like the team are fighting against you all of the time, perhaps
            you’ve pushed that lever too far. There’s no universally correct answer, but some control is a
            good thing and it’s therefore worth spending a few minutes looking at how much is right for
            your own team.


    Mind the gap
        Developers focus on the low-level detail
            If you’re working on a software development project at the moment, take a moment to look
            around at the rest of the team. How is the team structured? Does everybody have a well defined
            role and responsibilities? Who’s looking after the big picture; things like performance, scalability,
            availability, security and so on?

            As software developers, the code is our main
            focus but what happens if you have a team that only focusses on this low-level detail? Imagine
            a codebase where all of the latest programming language features are used, the code is nicely
            decoupled and testing is completely automated. The codebase can be structured and formatted
            to perfection but that’s no use if the system has scalability issues when deployed into a live
            environment.

        Architects dictate from their ivory towers
            Many teams do understand the
            importance of software architecture but will bring in somebody with the prestigious title of
            “Architect” only to stick them on a pedestal above the rest of the team. If anything, this instantly
            isolates the architect by creating an exaggerated gap between them and the development team
            they are supposed to be working with.

        Reducing the gap
            This gap between architects and developers leads to several problems:
                • The development team doesn’t respect the architect, regardless of whether the architect’s
                decisions are right or not.
                • The development team becomes demotivated.
                • Important decisions fall between the gap because responsibilities aren’t well defined.
                • The project eventually suffers because nobody is looking after the big picture.

            If you’re a software architect:
                • Be inclusive and collaborate: Get the development team involved in the software
                architecture process to help them understand the big picture and buy-in to the decisions
                you are making.
                • Get hands-on: If possible, get involved with some of the day-to-day development activities
                on the project to improve your understanding of how the architecture is being delivered.
                Depending on your role and team size, this might not be possible, so look at other ways of
                retaining some low-level understanding of what’s going on such as assisting with design
                and code reviews

!!!!        If you’re a software developer:
                • Understand the big picture: Taking some time out to understand the big picture will
                help you understand the context in which the architectural decisions are being made and
                enhance your understanding of the system as a whole.
!!!             • Challenge architectural decisions: With an understanding of the big picture, you now
                have the opportunity to challenge the architectural decisions being made. Architecture
                should be a collaborative process and not dictated by people that aren’t engaged in the
                project day-to-day. If you see something that you don’t understand or don’t like, challenge it.
!!!!            • Ask to be involved: Many projects have an architect who is responsible for the architecture and it’s
                this person who usually undertakes all of the “architecture work”. If you’re a
                developer and you want to get more involved, just ask. You might be doing the architect a favour!


    Where are the software architects of tomorrow?
!!!!    Think about answers to the following questions (the answers are from the book..4 5 6 though i am definetly also lacking..):
            1. When did you last code?
                • Earlier today, I’m a software developer so it’s part of the job.
            2. When did you last refactor?
                • I’m always looking to make my code the best I can, and that includes refactoring if
                necessary. Extract method, rename, pull up, push down … I know all that stuff.
            3. When did you last test your code?
                • We test continuously by writing automated tests either before, during or after we
                write any production code. We use a mix of unit, integration and acceptance testing.
            4. When did you last design something?
                • I do it all the time, it’s a part of my job as a software developer. I need to think about
                how something will work before coding it, whether that’s by sketching out a diagram or using TDD.
            5. When did you last design a software system from scratch? I mean, take a set of vague
            requirements and genuinely create something from nothing?
                • Well, there’s not much opportunity on my current project, but I have an open source
                project that I work on in my spare time. It’s only for my own use though.
            6. When did you last design a software system from scratch that would be implemented by a team of people ?
                • Umm, that’s not something I get to do.

 !!     Let’s face it, most software developers don’t get to take a blank sheet of paper and design software
        from scratch all that frequently, regardless of whether that design is up front or evolutionary and
        whether it’s a solo or collaborative exercise.


    Everybody is an architect, except when they’re not
        My big problem with the self-organising team idea is that we talk about it a lot in industry, yet
        I rarely see it in practice.
        Or, as I suspect, true self-organising teams are very
        few and far between. Striving to be self-organising is admirable but, for many software teams,
        this is like running before you can walk.

        Most projects don’t have anybody on the team with experience of the “big picture” stuff and this is evidenced
        by codebases that don’t make sense (big balls of mud), designs that are unclear, systems that are slow and so on. This
        type of situation is the one I see the most and, from a technical perspective, I recommend that
        one person on the team takes responsibility for the software architecture role.


    Software architecture as a consultant
        Although undertaking the software architecture role within a consulting context is fundamentally the same
        as undertaking the role in any other context, there are some potential gotchas to be aware of.

        Domain knowledge
            A good working knowledge of the business domain is essential. If you’re working within the
            finance industry, you should know something about how your particular part of the finance
            industry works (e.g. funds management, investment banking, retail banking, etc). Most business
            domains are more complex than they really should be and even seemingly simple domains can
            surprise you.

            A deep knowledge of the business domain only comes
            from working within that domain for an extended period of time but most consultants move
            between different customers, teams and business domains on a regular basis. Is it therefore fair
            to expect consultants to possess deep domain knowledge?

            There are a couple of approaches that I’ve seen people take. The first is to restrict yourself to
            working within a single business domain as a consultant so that you do gain a deep working
            knowledge of the business domain. As an example, a number of the IT consulting organisations
            that I’ve worked for have specialised in the investment banking industry, with consultants
            moving from bank to bank within that industry

            If I wanted to work for a bank, I’d work for a bank rather than a consulting
            organisation. As a result, I’m happy to regularly switch between business domains and this
            provides a degree of variety that you can’t necessarily get from working in a single domain

            To prevent this being an issue, I believe that there’s a skill in being able to understand enough
            about a new business domain to become proficient quickly. And that’s really my approach. If
            you’re a undertaking the software architecture role on a consulting basis, you need razor sharp
            analysis skills to understand the key parts of the business domain without getting trapped in a
            cycle of analysis paralysis.

        Authority
            The software architecture role is about technical leadership and part of this means that you need
            to get the whole team heading in the same direction. Dictating instructions to a team of software
            developers isn’t likely to be very effective if you’re not their immediate line manager, which
            is often the case if you’re supplementing a customer team.

            This is where the soft skills come
            into play, particularly those related to building relationships, creating trust and motivating the
            team. I’ve found that being a hands-on, coding architect goes a long way to getting a successful
            outcome too.


===============================================================================================================
===============================================================================================================
Part 3 - Designing software

    This part of the book is about the overall process of designing software, specifically looking at
    the things that you should really think about before coding


!!!!Architectural drivers
        Regardless of the process that you follow (traditional and plan-driven vs lightweight and
        adaptive), there’s a set of common things that really drive, influence and shape the resulting
        software architecture.

        1. Functional requirements
            In order to design software, you need to know something about the goals that it needs to satisfy.
            If this sounds obvious, it’s because it is. Having said that, I have seen teams designing software
            (and even building it) without a high-level understanding of the features that the software should
            provide to the end-users. Some might call this being agile, but I call it foolish. Even a rough, short
            list of features or user stories (e.g. a Scrum product backlog¹) is essential. Requirements drive
            architecture.

        2. Quality Attributes
            Quality attributes are represented by the non-functional requirements and reflect levels of
            service such as performance, scalability, availability, security, etc. These are mostly technical
            in nature and can have a huge influence over the resulting architecture, particularly if you’re
            building “high performance” systems or you have desires to operate at “Google scale”.

            Retrofitting high performance, scalability, security, availability, etc into an existing codebase is
            usually incredibly difficult and time-consuming.

        3. Constraints
            We live in the real world and the real world has constraints. For example, the organisation that
            you work for probably has a raft of constraints detailing what you can and can’t do with respect
            to technology choice, deployment platform, etc.

        4. Principles
            Where constraints are typically imposed upon you, principles are the things that you want to
            adopt in order to introduce consistency and clarity into the resulting codebase. These may be
            development principles (e.g. code conventions, use of automated testing, etc) or architecture
            principles (e.g. layering strategies, architecture patterns, etc).


!!!! Quality Attributes (non-functional requirements)
        Alternative, arguably better yet less commonly used names for non-functional requirements include
        “system characteristics” or “quality attributes”. A non-exhaustive list of the common quality attributes is as follows.

        Performance
            Performance is about how fast something is, usually in terms of response time or latency.
                • Response time: the time it takes between a request being sent and a response being
                received, such as a user clicking a hyperlink on a web page or a button on a desktop
                application.
                • Latency: the time it takes for a message to move through your system, from point A to
                point B.

            If you’ve ever been told that your software is “too slow” by your users, you’ll appreciate why some
            notion of performance is important.

        Scalability
            Scalability is basically about the ability for your software to deal with more users, requests, data,
            messages, etc. Scalability is inherently about concurrency and therefore dealing with more stuff
            in the same period of time (e.g. requests per second).

        Availability
            Availability is about the degree to which your software is operational and, for example, available
            to service requests. You’ll usually see availability measured or referred to in terms of “nines”, such
            as 99.99% (“four nines”) or 99.999% (“five nines”). These numbers refer to the uptime in terms of a
            percentage. The flip side of this coin is the amount of downtime that can be tolerated. An uptime
            of 99.9% (“three nines”) provides you with a downtime window of just over 1 minute per day for
            scheduled maintenance, upgrades and unexpected failure.

        Security
            Security covers everything from authentication and authorisation through to the confidentiality
            of data in transit and storage. As with performance, there’s a high probability that security is
            important to you at some level. Security should be considered for even the most basic of web
            applications that are deployed onto the Internet. The Open Web Application Security Project
            (OWASP)¹ is a great starting point for learning about security.

        Disaster Recovery
            What would happen if you lost a hard disk, server or data centre that your software was running
            on? This is what disaster recovery is all about. If your software system is mission critical, you’ll
            often hear people talking about business continuity processes too, which state what should
            happen in the event of a disaster in order to retain continued operation.

        Accessibility
            Accessibility usually refers to things like the W3C accessibility standards², which talk about how
            your software is accessible to people with disabilities such as visual impairments.

        Monitoring
            Some organisations have specific requirements related to how software systems should be
            monitored to ensure that they are running and able to service requests. This could include
            integrating your software with platform specific monitoring capabilities (e.g. JMX on the Java
            platform) or sending alerts to a centralised monitoring dashboard (e.g. via SNMP) in the event
            of a failure.

        Management
            Monitoring typically provides a read-only view of a software system and sometimes there
            will be runtime management requirements too. For example, it might be necessary to expose
            functionality that will allow operational staff to modify the runtime topology of a system, modify
            configuration elements, refresh read-only caches, etc.

        Audit
            There’s often a need to keep a log of events (i.e. an audit log) that led to a change in data or
            behaviour of a software system, particularly where money is involved. Typically such logs need
            to capture information related to who made the change, when the change was made and why the
            change was made.

        Flexibility
            Flexibility is a somewhat overused and vague term referring to the “flexibility” of your software
            to perform more than a single task, or to do that single task in a number of different ways. A good
            example of a flexibility requirement would be the ability for non-technical people to modify the
            business rules used within the software.

        Extensibility
            Extensibility is also overused and vague, but it relates to the ability to extend the software to do
            something it doesn’t do now, perhaps using plugins and APIs. Some off-the-shelf products (e.g.
            Microsoft Dynamics CRM) allow non-technical end-users to extend the data stored and change
            how other users interact with that data.

        Maintainability
            Maintainability is often cited as a requirement but what does this actually mean? As software
            developers we usually strive to build “maintainable” software but it’s worth thinking about who
            will be maintaining the codebase in the future. Maintainability is hard to quantify, so I’d rather
            think about the architecture and development principles that we’ll be following instead because
            they are drivers for writing maintainable code.

        Legal, Regulatory and Compliance
            Some industries are strictly governed by local laws or regulatory bodies, and this can lead to
            additional requirements related to things like data retention or audit logs. As an example, most
            finance organisations (investment banks, retail banks, trust companies, etc) must adhere to a
            number of regulations (e.g. anti-money laundering) in order to retain their ability to operate in
            the market.

        Internationalisation (i18n)
            Many software systems, particularly those deployed on the Internet, are no longer delivered in
            a single language. Internationalisation refers to the ability to have user-facing elements of the
            software delivered in multiple languages. This is seemingly simple until you try to retrofit it to
            an existing piece of software and realise that some languages are written right-to-left.

        Localisation (L10n)
            Related to internationalisation is localisation, which is about presenting things like numbers,
            currencies, dates, etc in the conventions that make sense to the culture of the end-user.
            Sometimes internationalisation and localisation are bundled up together under the heading of
            “globalisation”.

!!!     There are many quality attributes that we could specify for our software systems but they don’t
        all have equal weighting. Some are more applicable than others, depending on the environment
        that you work in and the type of software systems that you build. A web-based system in the
        finance industry will likely have a different set of quality attributes to an internal system used
        within the telco industry. My advice is to learn about the quality attributes common within your
        domain and focus on those first when you start building a new system or modifying an existing system.


!!!! Working with non-functional requirements       (Dan this process is very practical and important to know )
        Regardless of what you call them, you’ll often need to put some effort into getting the list of
        non-functional requirements applicable to the software system that you’re building.

        1.Capture  (Dan: ask the stakeholders what they want concerning the non-functional requirements)
            If you ask a business sponsor what level of system availability they
            want, you’ll probably get an answer similar to “100%”, “24 by 7 by 365” or “yes please, we want all of it”.

        2.Refine
            Once you’ve started asking those tricky questions related to non-functional requirements, or
            you’ve been fortunate enough to receive some information about them, you’ll probably need to
            refine them.
            On the few occasions that I’ve received a functional requirements specification that did include
            some information about non-functional requirements, they’ve usually been unhelpfully vague.

                Example:
                     It said things like:
                    • Performance: The system must be fast.
                    • Security: The system must be secure.
                    • Availability: The system should be running 100% of the time.

            Rather than asking how much availability is needed and getting the inevitable “24 by 7” answer, you
            can vary the questions depending on who you are talking to. For example:
                • “How much system downtime can you tolerate?”
                • “What happens if the core of the system fails during our normal working hours of 9am until 6pm?”
                • “What happens if the core of the system fails outside of normal working hours?”
                • Why does the system need to be available?
                • When we talk about “high security”, what is it that we’re protecting?
                • How many concurrent users should the system support on average? What about peak times?
                • What response time is deemed as acceptable? Is this the same across all parts of the system
                or just specific features?
                • How exactly do we need to secure the system? Do we really need to encrypt the data or
                is restricted access sufficient?

            If you can associate some quantity to the non-functional requirements (e.g. number of users,
            data volumes, maximum response times, etc), you can can write some acceptance criteria and
            objectively test them.

        3. Challenge
            With this in mind, we all know what response we’ll get if we ask people whether they need
            something. They’ll undoubtedly say, “yes”. This is why prioritising functional requirements, user
            stories, etc is hard. Regardless of the prioritisation scale that you use (MoSCoW¹, High/Medium/Low, etc),
            everything will end up as a “must have” on the first attempt at prioritisation. You
            could create a “super-must have” category, but we know that everything will just migrate there.
            A different approach is needed and presenting the cost implications can help focus the mind.
            For example:
                • Architect: “You need a system with 100% uptime. Building that requires lots of redundancy
                to remove single points of failure and we would need two of everything plus a lot of
                engineering work for all of the automatic failover. It will cost in the region of $1,000,000.
                Alternatively we can build you something simpler, with the caveat that some components
                would need to be monitored and restarted manually in the event of a failure. This could
                cost in the region of $100,000. Which one do you need now?”
                • Sponsor: “Oh, if that’s the case, I need the cheaper solution.”
    !!!     Anything is possible but everything has a trade-off. Explaining those trade-offs can help find the
            best solution for the given context.


    Constraints
        Like quality attributes, constraints can drive, shape and influence the architecture of
        a software system. They’re typically imposed upon you too, either by the organisation that you
        work for or the environment that you work within. Constraints come in many different shapes
        and sizes.

        Time and budget constraints
            Time and budget are probably the constraints that most software developers are familiar with,
            often because there’s not enough of either.

        Technology constraints
            There are a number of technology related constraints that we often come up against when
            building software, particularly in large organisations:

                • Approved technology lists
                • Existing systems and interoperability
                • Target deployment platform
                • Technology maturity
                • Open source:
                    Confusion around open source licenses also prevents some organisations from fully adopting open source too.
                • Vendor “relationships”:
                    As with many things in life, it’s not what you know, it’s who you know. Many partnerships are still
                    forged on the golf course by vendors who wine and dine Chief Technology Officers
                • Past failures:
                • Internal intellectual property:

        People constraints
            For example:
            • How large is your development team?
            • What skills do they have?
            • How quickly can you scale your development team if needed?
            • Are you able to procure training, consulting and specialists if needed?
            • If you’re handing over your software after delivery, will the maintenance team have the
            same skills as your development team?

    Constraints can be prioritised
        As a final note, it’s worth bearing in mind that constraints can be prioritised. Just like functional
        requirements, some constraints are more important than others and you can often use this to
        your advantage.

        One of the major constraints was an approved list of technologies that included your typical heavyweight Java
        EE stack. The other was a strict timescale constraint.
        When we prepared our financial proposal, we basically said something along the lines of, “yes,
        we’re confident that we can deliver this system to meet the deadline, but we’ll be using some
        technologies that aren’t on your approved technology list, to accelerate the project”. Our proposal
        was accepted. In this situation, the timescale constraint was seen as much more important than
        using only the technologies on the approved technology list and, in effect, we prioritised one
        constraint over the other. Constraints are usually obstacles that you need to work around, but
        sometimes you can trade the off against one another.


!!! Principles
        While constraints are imposed upon you, principles are the things that you want to adopt in
        order to introduce standard approaches, and therefore consistency, into the way that you build
        software. There are a number of common principles, some related to development and others
        related to architecture.

!!!     Development principles
            • Coding standards and conventions: “We will adopt our in-house coding conventions for
                [Java|C#|etc], which can be found on our corporate wiki.”
            • Automated unit testing: “Our goal is to achieve 80% code coverage for automated unit
                tests across the core library, regardless of whether that code is developed using a test-first or test-last approach.”
            • Static analysis tools: “All production and test code must pass the rules defined in
                [Checkstyle|FxCop|etc] before being committed to source code control.”
            • etc

!!!     Architecture principles
            • Layering strategy: A layered architecture usually results in a software system that has a
                high degree of flexibility because each layer is isolated from those around it. For example,
                you may decompose your software system into a UI layer, a business layer and a data access
                layer. Making the business layer completely independent of the data access layer means
                that you can (typically) switch out the data access implementation without affecting the
                business or UI layers. You can do this because the data access layer presents an abstraction
                to the business layer rather than the business layer directly dealing with the data storage
                mechanism itself. If you want to structure your software this way, you should ensure that
                everybody on the development team understands the principle. “No data access logic in
                the UI components or domain objects” is a concrete example of this principle in action

            • Placement of business logic: Sometimes you want to ensure that business logic always
                resides in a single place for reasons related to performance or maintainability. In the case
                of Internet-connected mobile apps, you might want to ensure that as much processing as
                possible happens on the server. Or if you’re integrating with a legacy back-end system that
                already contains a large amount of business logic, you might want to ensure that nobody
                on the team attempts to duplicate it.

            • High cohesion, low coupling, SOLID¹, etc: There are many principles related to the
                separation of concerns, focussing on building small highly cohesive building blocks that
                don’t require too many dependencies in order to do their job.

            • Stateless components: If you’re building software that needs to be very scalable, then
                designing components to be as stateless as possible is one way to ensure that you can
                horizontally scale-out your system by replicating components to share the load. If this is
                your scalability strategy, everybody needs to understand that they must build components
                using the same pattern. This will help to avoid any nasty surprises and scalability
                bottlenecks in the future.

            • Stored procedures: you either love them or you hate them. There are advantages and disadvantages to using or
                not using stored procedures, but I do prefer it when teams just pick one approach for data
                access and stick to it. There are exceptions to every principle though.

            • Domain model - rich vs anaemic: Some teams like having a very rich domain model
                in their code, building systems that are very object-oriented in nature. Others prefer a
                more anaemic domain model where objects are simply data structures that are used by
                coarse-grained components and services. Again, consistency of approach goes a long way.

            • Use of the HTTP session: If you’re building a website, you may or may not want to
                use the HTTP session for storing temporary information between requests. This can often
                depend on a number of things including what your scaling strategy is, where sessionbacked objects are
                actually stored, what happens in the event of a server failure, whether
                you’re using sticky sessions, the overhead of session replication, etc. Again, everybody on
                the development team should understand the desired approach and stick to it.

            • Always consistent vs eventually consistent: Many teams have discovered that they
                often need to make trade-offs in order to meet complex non-functional requirements.
                For example, some teams trade-off data consistency for increased performance and/or
                scalability. Provided that we do see all Facebook status updates, does it really matter if we
                all don’t see them immediately? Your context will dictate whether immediate or delayed
                consistency is appropriate, but a consistent approach is important.

        Beware of “best practices”
            If you regularly build large enterprise software systems, you might consider most of the principles
            that I’ve just listed to be “best practices”. But beware. Even the most well-intentioned principles
            can sometimes have unintended negative side-effects. That complex layering strategy you want
            to adopt to ensure a complete separation of concerns can suck up a large percentage of your time
            if you’re only building a quick, tactical solution.
            Principles are usually introduced for a good reason, but that doesn’t make them good all of the time.


    Technology is not an implementation detail
        I firmly believe that technology choices should be included on architecture diagrams but there’s
        a separate question here about why people don’t feel comfortable making technology decisions.
        Saying that “it can be built with any technology” doesn’t mean that it should. Here’s why.

        1. Do you have complex non-functional requirements?
            True, most software systems can be built with pretty much any technology; be it Java, .NET,
            Ruby, Python, PHP, etc. If you look at the data storage requirements for most software systems,
            again, pretty much any relational database is likely to be able to do the job.

            But what happens if you do have complex non-functional requirements such as high performance
            and/or scalability? Potentially things start to get a little trickier and you should really understand
            whether your technology (and architecture) choices are going to work. If you don’t consider your
            non-functional requirements, there’s a risk that your software system won’t satisfy its goals.

        2. Do you have constraints?
            Many organisations have constraints related to the technologies that can be used and the
            skills (people) that are available to build software. Some even dictate that software should be
            bought and/or customised rather than built. Constraints can (and will) influence the software
            architecture that you come up with. Challenge them by all means, but ignore them and you
            risk delivering a software system that doesn’t integrate with your organisation’s existing IT
            environment.

        3. Do you want consistency?
            People often ask me questions like, “does it really matter which logging framework we choose?”.
            If you want everybody on the development team to use the same one, then yes, it does. Some
            people are happy to allow anybody on the development team to download and use any open
            source library that they want to. Others realise this can lead to problems if left unchecked. I’m
            not saying that you should stifle innovation, but you should really only have a single logging,
            dependency injection or object-relational mapping framework in a codebase

        Every decision has trade-offs
            Likewise with many cloud providers, but even these have their
            trade-offs related to deployment, monitoring, management, cost, persistent access to disk and so on.
            At the end of the day, every technology choice you make will have a trade-off whether that’s
            related to performance, scalability, maintainability, the ability to find people with the right
            experience, etc. Understanding the technology choices can also assist with high-level estimating
            and planning, which is useful if you need to understand whether you can achieve your goal given
            a limited budget.

!!!!!       If you don’t understand the trade-offs that you’re making by choosing technology X over Y,
            you shouldn’t be making those decisions. It’s crucial that the people designing software systems
            understand technology. This is why software architects should be master builders.


    More layers = more complexity
        All architecture decisions involve trade-offs. More moving parts means more
        work designing, developing, testing and deploying. Despite what vendor marketing hype might
        say, nothing is ever free and you need to evaluate the pros and cons of adding additional layers
        into a design, particularly if they result in additional inter-process communication.


    Collaborative design can help and hinder
        The effectiveness of the overall team comes down to a number of factors, one of them being
        people’s willingness to leave their egos at the door and focus on delivering the best solution
        given the context. Sometimes though, individual specialisms can work against a team; simply
        through a lack of experience in working as a team or because ego gets in the way of the common
        goal. If there’s a requirement to provide a way for a user to view and manipulate data on our 3-tier
        web application, you’ll probably get a different possible approach from each of your specialists:
            • Web developer: Just give me the data as JSON and we can do anything we want with it on
                the web-tier. We can even throw in some JQuery to dynamically manipulate the dataset
                in the browser.
            • Server-side developer: We should reuse and extend some of the existing business logic
                in the middle-tier service layer. This increases reuse, is more secure than sending all of the
                data to the web-tier and we can write automated unit tests around it all.
            • Database developer: You’re both idiots. It’s way more efficient for me to write a stored
                procedure that will provide you with exactly the data that you need. :-)

 !!!    Experience influences software design
            Our own knowledge, experience and preferences tend to influence how we design software,
            particularly if it’s being done as a solo activity. In the absence of communication, we tend to
            make assumptions about where components will sit and how features will work based upon our
            own mental model of how the sofware should be designed. Getting these assumptions out into
            the open as early as possible can really help you avoid some nasty surprises before it’s too late.
            One of the key reasons I prefer using a whiteboard to design software is because it encourages
            a more collaborative approach than somebody sitting on their own in front of their favourite
            modelling tool on a laptop. If you’re collaborating, you’re also communicating and challenging each other


    Software architecture is a platform for conversation
        Project teams might have a clear vision about what the software should do but often you’ll hear phrases like
        this, often late in the delivery cycle.
            • “Nobody told us you needed a production database created on this server.”
            • “We can’t upgrade to [Java 7|.NET 4] on that server until system X is compatible.”
            • “We don’t have spare production licenses.”
            • “Sorry, that contravenes our security policy.”
            • “Sorry, we’ll need to undertake some operational acceptance testing before we promote
            your application into the production environment.”
            • “How exactly are we supposed to support this application?”
            • “I don’t care if you have a completely automated release process … I’m not giving you the
            production database credentials for your configuration files.”
            • “We need to run this past the risk and compliance team.”
            • “There’s no way your system is going on the public cloud.”

        The people who use your software are just one type of stakeholder. There are usually many
        others including:
            • Current development team: The current team need to understand the architecture and
            be aware of the drivers so that they produce a solution that is architecturally consistent
            and “works”.
            • Future development team: Any future development/maintenance teams need to have the
            same information to hand so that they understand how the solution works and are able to
            modify it in a consistent way.
            • Other teams: Often your software needs to integrate with other systems within the
            environment, from bespoke software systems through to off-the-shelf vendor products,
            so it’s crucial that everybody agrees on how this will work.
            • Database administrators: Some organisations have separate database teams that need
            to understand how your solution uses their database services (e.g. from design and
            optimisation through to capacity planning and archiving).
            • Operations/support staff: Operational staff typically need to understand how to run
            and support your system (e.g. configuration and deployment through to monitoring and
            problem diagnostics).
            • Compliance, risk and audit: Some organisations have strict regulations that they need
            to follow and people in your organisation may need to certify that you’re following them
            too.
            • Security team: Likewise with security; some organisations have dedicated security teams
            that need to review systems before they are permitted into production environments.

        If you think you can put together a software architecture in an ivory tower on your own, you’re probably
        doing it wrong. Software architectures don’t live in isolation and the software design process
        is a platform for conversation. A five minute conversation now could help capture those often
        implied architectural drivers and improve your chance of a successful delivery


===============================================================================================================
===============================================================================================================
Part 4 - Visualising software
    This part of the book is about visualising software architecture using a collection of lightweight,
    yet effective, sketches.

    We have a failure to communicate
        However, it seems we’ve forgotten how to visualise the actual software that we’re building. I’m
        not just referring to post-project documentation, this also includes communication during the
        software development process.

        Having run architecture katas with thousands of people over a number of years, I
        can say with complete confidence that visualising the architecture of a software system is a skill
        that very few people have. People can draw diagrams, but those diagrams often leave much to
        the imagination. Almost nobody uses a formal diagramming notation to describe their solutions
        too, which is in stark contrast to my experience of working with software teams a decade ago.

        Abandoning UML
            As an industry, we do have the Unified Modelling Language (UML), which is a formal
            standardised notation for communicating the design of software systems. However, while you
            can argue about whether UML offers an effective way to communicate software designs or not,
            that’s often irrelevant because many teams have already thrown out UML or simply don’t know
            it.

            Such teams typically favour informal boxes and lines style sketches instead but often these
            diagrams don’t make much sense unless they are accompanied by a detailed narrative, which
            ultimately slows the team down

            My approach is to use a collection of simple diagrams each showing a different part of the same
            overall story, paying close attention to the diagram elements if I’m not using UML.

        Agility requires good communication
            If you want to ensure that everybody is contributing to the same end-goal, you need to be able to effectively
            communicate the vision of what it is you’re building. And if you want agility and the ability to
            move fast, you need to be able to communicate that vision efficiently too.


    The need for sketches
        Software architecture already has a poor reputation and the mention of “pictures” tends to
        bring back memories of analysis paralysis and a stack of UML diagrams that few people truly understand

        Test driven development vs diagrams
!!!!        I’m very much a visual person myself and fall into latter camp. I like being able to visualise a
            problem before trying to find a solution. Describe a business process to me and I’ll sketch up a
            summary of it. Talk to me about a business problem and I’m likely to draw a high-level domain
            model. Visualising the problem is a way for me to ask questions and figure out whether I’ve
            understood what you’re saying. I also like sketching out solutions to problems, again because
            it’s a great way to get everything out into the open in a way that other people can understand
            quickly

        Why should people learn how to sketch?
            Put simply, agility (and therefore moving fast)
            requires good communication. Sketching is a fantastic way to communicate a lot of information
            in a relatively short amount of time yet it’s a skill that we don’t often talk about in the software
            industry any more. There are several reasons for this:
                1. Many teams instantly think of UML but they’ve dropped it as a communication method
                or never understood it in the first place. After all, apparently UML “isn’t cool”.
                2. Many teams don’t do class design in a visual way anymore because they prefer TDD instead.

        Sketching isn’t art
            But it’s not the ability to create a work of art that’s important. Rather, it’s the ability to get to bottom of
            something quickly and to summarise the salient points in a way that others can understand. It’s
            about communicating in a simple yet effective and efficient way.

        Sketches are not comprehensive models
            Just to be clear, I’m not talking about detailed modelling, comprehensive UML models or
            model-driven development. This is about effectively and efficiently communicating the software
            architecture of the software that you’re building through one or more simple sketches. This
            allows you to:
                • Help everybody understand the “big picture” of what is being built.
                • Create shared vision of what you’re building within the development team.
                • Provide a focal point for the development team (e.g. by keeping the sketches on the wall)
                    so that everybody in the development team remains focussed on what the software is and
                    how it is being built.
                • Provide a point of focus for those technical conversations about how new features should
                    be implemented.
                • Provide a map that can be used by software developers to navigate the source code.
                • Help people understand how what they are building fits into the “bigger picture”.
                • Help you to explain what you’re building to people outside of the development team (e.g.
                    operations and support staff, non-technical stakeholders, etc).
                • Fast-track the on-boarding of new software developers to the team.
                • Provide a starting point for techniques such as risk-storming.

  !!!       Context, containers and components diagrams are usually sufficient.

        Sketching can be a collaborative activity
            Unfortunately, drawing diagrams seems to have fallen out of favour with many software
            development teams but it’s a skill that should be in every software developer’s toolbox because
            it paves the way for collaborative software design and makes collective code ownership easier.


    Ineffective sketches
        but the diagrams do need to
        be comprehensible and this is where things start to get tricky. Having run software architecture
        sketching workshops for thousands of people over the past few years, I can say without doubt
        that the majority of people do find this a very hard thing to do. The small selection of photos
        that follow are taken from these workshops, where groups of people have tried to communicate
        their software solution to the financial risk system case study. Have a look at each in turn and
        ask yourself whether they communicate the software architecture of the solution in an effective
        way. Some of the diagrams make use of colour, so apologies if you’re reading this on a black and
        white e-book reader.

    Boxes and no lines
        When people talk about software architecture, they often refer to “boxes and lines”. This next
        diagram has boxes, but no lines.

        (example of bad sketch follows)
            This is a three-tier solution (I think) that uses the Microsoft technology stack. There’s an ASP.NET
            web thing at the top, which I assume is being used for some sort of user interaction, although
            that’s not shown on the diagram. The bottom section is labelled “SQL Server” and there are lots
            of separate “database cans”. To be honest though, I’m left wondering whether these are separate
            database servers, schemas or tables.
            Finally, in the middle, is a collection of boxes, which I assume are things like components,
            services, modules, etc. From one perspective, it’s great to see how the middle-tier of the
            overall solution has been decomposed into smaller chunks and these are certainly the types of
            components/services/modules that I would expect to see for such a solution. But again, there are
            no responsibilities and no interactions.

!!!!!       Software architecture is about structure, which is about things (boxes) and how they interact (lines).
            This diagram has one, but not the other. It’s telling a story, but not the whole story.

    The “functional view”
        (example of bad sketch follows)

        This diagram suffers from the same problem as the previous diagram (no responsibilities and
        no interactions) plus we additionally have a colour coding to decipher. Can you work out what
        the colour coding means? Is it related to input vs output functions? Or perhaps it’s business vs
        infrastructure? Existing vs new? Buy vs build? Or maybe different people simply had different
        colour pens! Who knows

    The airline route map
        (example of bad sketch follows...that looks like airline routes...lots and lots of lines/interactions)

        The left of the diagram is equally confusing, with various lines of differing colours and styles
        zipping across one another. If you look carefully you’ll see the letters “UI” upside-down. Perhaps
        this diagram makes more sense if you fold it like an Origami challenge?

    Generically true
          (example of bad sketch follows)

    The “logical view”
         (example of bad sketch follows)

    Deployment vs execution context
        (example of bad sketch follows...a java app where some jars are drawn as being on a unit machine)

        By deduction then, I think both of those JAR files are actually standalone applications and that’s what
        I’d like to see on the diagram.
        Rather than the deployment mechanism, I want to understand the execution context.

    Too many assumptions
        (example of bad sketch follows..)

        The lines between the web server and the application server have no information about how
        this communication occurs. Is it SOAP? RESTful services? XML over HTTP? Remote method
        invocation? Windows Communication Foundation? Asynchronous messaging? It’s not clear and
        this concerns me for three reasons:
            1. Constraints: If you’re working in an environment with existing constraints, the technology choices may
            have be made for you already. For example, perhaps you have standards about inter-process communication or
            firewalls that only permit certain types of traffic through them.
            2. Non-functional requirements: The choice of technology and protocol may have an impact on whether you meet
            your non-functional requirements, particularly if you are dealing with high performance, scalability or security.
            3. Complexity: I’ve worked with software teams who have never created an n-tier architecture before and they
            are often under the illusion that this style of architecture can be created “for free”. In the real world,
            more layers means more complexity.

!!!!    Granted there are many options and often teams don’t like committing early without putting
        together some prototypes. No problem, just annotate those lines on the diagram with the list of
        potential options instead so we can at least have a better conversation.

    Stormtroopers
        (example of bad sketch follows..)

        To pick up on something you may have noticed from previous sketches, I regularly see diagrams
        that include unlabelled users/actors. Essentially they are faceless clones.


    C4: context, containers, components and classes
        When describing software through pictures, we have a tendency to create a single uber-diagram that includes as
        much detail as possible at every level of abstraction simultaneously. This may be because we’re anticipating
        questions or because we’re a little too focussed on the specifics of how the system works at a code level.
        Such diagrams are typically cluttered, complex and confusing. Picking up a tool such
        as Microsoft Visio, Rational Software Architect or Sparx Enterprise Architect usually adds to the
        complexity rather than making life easier.

!!!!    A better approach is to create a number of diagrams at varying levels of abstraction. A number
        of simpler diagrams can describe software in a much more effective way than a single complex
        diagram that tries to describe everything

 !!!!!  A common set of abstractions
            If software architecture is about the structure of a software system, it’s worth understanding
            what the major building blocks are and how they fit together at differing levels of abstraction.

            (see bookPics -> 1 - C4 Abstractions )

            Assuming an OO programming language, the way that I like to think about structure is as follows
            … a software system is made up of a number of containers, which themselves are made up of
            a number of components, which in turn are implemented by one or more classes. It’s a simple
            hierarchy of logical building blocks that can be used to model most software systems.

                • Classes: for most of us in an OO world, classes are the smallest building blocks of our software systems.
                • Components: a component can be thought of as a logical grouping of one or more classes.
                    For example, an audit component or an authentication service that is used by other
                    components to determine whether access is permitted to a specific resource. Components
                    are typically made up of a number of collaborating classes, all sitting behind a higher level contract.
                • Containers: a container represents something in which components are executed or where
                    data resides. This could be anything from a web or application server through to a rich
                    client application or database. Containers are typically executables that are started as a
                    part of the overall system, but they don’t have to be separate processes in their own right.
                    For example, I treat each Java EE web application or .NET website as a separate container
                    regardless of whether they are running in the same physical web server process. The key
                    thing about understanding a software system from a containers perspective is that any
                    inter-container communication is likely to require a remote interface such as a SOAP web
                    service, RESTful interface, Java RMI, Microsoft WCF, messaging, etc.
                • Systems: a system is the highest level of abstraction and represents something that delivers
                    value to somebody. A system is made up of a number of separate containers. Examples
                    include a financial risk management system, an Internet banking system, a website and so on.

 !!!!   Summarising the static view of your software
            With this set of abstractions in mind, I tend to draw the following types of diagrams when
            summarising the static view of my software:
                1. Context: A high-level diagram that sets the scene; including key system dependencies and actors.
                2. Container: A container diagram shows the high-level technology choices, how responsibilities are distributed across them and how the containers communicate.
                3. Component: For each container, a component diagram lets you see the key logical
                    components and their relationships.
                4. Classes: This is an optional level of detail and I will draw a small number of high-level
                    UML class diagrams if I want to explain how a particular pattern or component will be (or
                    has been) implemented. The factors that prompt me to draw class diagrams for parts of the
                    software system include the complexity of the software plus the size and experience of the
                    team. Any UML diagrams that I do draw tend to be sketches rather than comprehensive
                    models.

 !!!        My advice here is to be conscious of colour-coding, line style, shapes, etc and let a
            consistent notation evolve naturally within your team. Including a simple key/legend on each
            diagram to explain the notation will help.
            try to avoid a diagram that is simply a collection of labelled boxes. Annotating
            those boxes with responsibilities helps to avoid ambiguity while providing a nice “at a glance” view.

        Diagrams should be simple and grounded in reality
            A single diagram can quickly become cluttered and confused, but a collection of simple diagrams
            allows you to effectively present the software from a number of different levels of abstraction.
            This means that illustrating your software can be a quick and easy task that requires little ongoing
            effort to keep those diagrams up to date. You never know, people might even understand them too.


!!! Context diagram                 (all the info below for this is important)
        A context diagram can be a useful starting point for diagramming and documenting a software
        system, allowing you to step back and look at the big picture.

        Intent
            A context diagram helps you to answer the following questions.
            1. What is the software system that we are building (or have built)?
            2. Who is using it?
            3. How does it fit in with the existing IT environment?

        Structure
            Draw a simple block diagram showing your system as a box in the centre, surrounded by its
            users and the other systems that it interfaces with.
            Detail isn’t important here as it’s your wide angle view showing a big picture of the system landscape. The
            focus should be on people and systems rather than technologies and protocols.

        Users, actors, roles, personas, etc
            These are the users of the system.

        IT systems
            Depending on the environment and chosen solution, the other IT systems you might want to
            show on a context diagram for the risk system include:
            • Trade Data System (the source of the financial trade data)
            • Reference Data System (the source of the reference data)
            • Central Monitoring System (where alerts are sent to)
            • Active Directory or LDAP (for authenticating and authorising users)
            • Microsoft SharePoint or another content/document management system (for distributing the reports)
            • Microsoft Exchange (for sending e-mails to users)

        Interactions
            It’s useful to annotate the interactions (user <-> system, system <-> system, etc) with some
            information about the purpose rather than simply having a diagram with a collection of boxes
            and ambiguous lines connecting everything together. For example, when I’m annotating user to
            system interactions, I’ll often include a short bulleted list of the important use cases/user stories
            to summarise how that particular type of user interacts with the system

        Motivation
            You might ask what the point of such a simple diagram is. Here’s why it’s useful:
                • It makes the context explicit so that there are no assumptions.
                • It shows what is being added (from a high-level) to an existing IT environment.
                • It’s a high-level diagram that technical and non-technical people can use as a starting point for discussions.
                • It provides a starting point for identifying who you potentially need to go and talk to as
                far as understanding inter-system interfaces is concerned.

            A context diagram doesn’t show much detail but it does help to set the scene and is a starting
            point for other diagrams. Finally, a context diagram should only take a couple of minutes to
            draw, so there really is no excuse not to do it.

        Audience
            • Technical and non-technical people, inside and outside of the immediate software development team.

        Example
            (see "2 - Context diagram example.png" for a good example.)


!!! Container diagram        (all the info below for this is important)
        Once you understand how your system fits in to the overall IT environment with a context
        diagram, a really useful next step can be to illustrate the high-level technology choices with a
        container diagram.

        Intent
            A container diagram helps you answer the following questions.
            1. What is the overall shape of the software system?
            2. What are the high-level technology decisions?
            3. How are responsibilities distributed across the system?
            4. How do containers communicate with one another?
            5. As a developer, where do I need to write code in order to implement features?

        Structure
            Draw a simple block diagram showing your key technology choices.

            These example diagrams show the various web servers, application servers, standalone applications, databases,
            file systems, etc that make up the risk system. To enrich the diagram, often it’s
            useful to include some of the concepts from the context diagram diagram, such as users and the
            other IT systems that the system has a dependency on.

        Containers
            By “containers”, I mean the logical executables or processes that make up your software system; such as:
                • Web servers¹ (e.g. Apache HTTP Server, Apache Tomcat, Microsoft IIS, WEBrick, etc)
                • Application servers (e.g. IBM WebSphere, BEA/Oracle WebLogic, JBoss AS, etc)
                • Enterprise service buses and business process orchestration engines (e.g. Oracle Fusion middleware, etc)
                • SQL databases (e.g. Oracle, Sybase, Microsoft SQL Server, MySQL, PostgreSQL, etc)
                • NoSQL databases (e.g. MongoDB, CouchDB, RavenDB, Redis, Neo4j, etc)
                • Other storage systems (e.g. Amazon S3, etc)
                • File systems (especially if you are reading/writing data outside of a database)
                • Windows services
                • Standalone/console applications (i.e. “public static void main” style applications)
                • Web browsers and plugins
                • cron and other scheduled job containers

            For each container drawn on the diagram, you could specify:
                • Name: The logical name of the container (e.g. “Internet-facing web server”, “Database”, etc)
                • Technology: The technology choice for the container (e.g. Apache Tomcat 7, Oracle 11g, etc)
                • Responsibilities: A very high-level statement or list of the container’s responsibilities.
                You could alternatively show a small diagram of the key components that reside in each
                container, but I find that this usually clutters the diagram.

!!!!        If you’re struggling to understand whether to include a box on a containers diagram, simply ask
            yourself whether that box will be (or can be) deployed on a separate piece of physical or virtual
            hardware. Everything that you show on a containers diagram should be deployable separately.
            This doesn’t mean that you must deploy them on separate infrastructure, but they should be able
            to be deployed separately

        Interactions
            Typically, inter-container communication is inter-process communication. It’s very useful to
            explicitly identify this and summarise how these interfaces will work. As with any diagram,
            it’s useful to annotate the interactions rather than simply having a diagram with a collection of
            boxes and ambiguous lines connecting everything together.
            Useful information to add includes:
                • The purpose of the interaction (e.g. “reads/writes data from”, “sends reports to”, etc).
                • Communication method (e.g. Web Services, REST, Java Remote Method Invocation,
                    Windows Communication Foundation, Java Message Service).
                • Communication style (e.g. synchronous, asynchronous, batched, two-phase commit, etc)
                • Protocols and port numbers (e.g. HTTP, HTTPS, SOAP/HTTP, SMTP, FTP, RMI/IIOP, etc).

        System boundary
            If you do choose to include users and IT systems that are outside the scope of what you’re
            building, it can be a good idea to draw a box around the appropriate containers to explicitly
            demarcate the system boundary. The system boundary corresponds to the single box that would
            appear on a context diagram

        Motivation
            Where a context diagram shows your software system as a single box, a container diagram opens
            this box up to show what’s inside it. This is useful because:
                • It makes the high-level technology choices explicit.
                • It shows where there are relationships between containers and how they communicate.
                • It provides a framework in which to place components (i.e. so that all components have a home).
                • It provides the often missing link between a very high-level context diagram and (what is
                usually) a very cluttered component diagram showing all of the logical components that
                make up the entire software system

            As with a context diagram, this should only take a couple of minutes to draw, so there really is
            no excuse not to do it either.

        Audience
            • Technical people inside and outside of the immediate software development team; including everybody from
            software developers through to operational and support staff.

        Example
            The following diagram shows the logical containers that make up the techtribes.je website.
                (see "3 - Container diagram example")

            Put simply, techtribes.je is made up of an Apache Tomcat web server that provides users with
            information, and that information is kept up to date by a standalone content updater process.


    Component diagram
        Following on from a container diagram showing the high-level technology decisions, I’ll then
        start to zoom in and decompose each container further. However you decompose your system
        is up to you, but I tend to identify the major logical components and their interactions. This
        is about partitioning the functionality implemented by a software system into a number of
        distinct components, services, subsystems, layers, workflows, etc. If you’re following a “pure
        Object Oriented” or Domain-Driven Design approach, then this may or may not work for you.

        Intent
            A component diagram helps you answer the following questions.
                1. What components/services is the system made up of?
                2. It is clear how the system works at a high-level?
                3. Do all components/services have a home (i.e. reside in a container)?

        Structure
            Whenever people are asked to draw “architecture diagrams”, they usually end up drawing
            diagrams that show the logical components that make up their software system. That is basically
            what this diagram is about, except we only want to see the components that reside within a single
            container at a time.

            Whenever I draw a component diagram, it typically only shows the components that reside
            within a single container. This is by no means a rule though and, for small software systems,
            often you can show all of the components across all of the containers on a single diagram. If that
            diagram starts to become too cluttered, maybe it’s time to break it apart.

        Components
            If you were designing a solution to the financial risk system, you might include components like:
                • Trade data system importer
                • Reference data system importer
                • Risk calculator
                • Authentication service
                • System driver/orchestrator
                • Audit component
                • Notification component (e.g. e-mail)
                • Monitoring service
                • etc

!!!         These components are the coarse-grained building blocks of your system and you should be
            able to understand how a use case/user story/feature can be implemented across one or more
            of these components. If you can do this, then you’ve most likely captured everything. If, for
            example, you have a requirement to audit system access but you don’t have an audit component
            or responsibilities, then perhaps you’ve missed something.

            For each of the components drawn on the diagram, you could specify:
                • Name: The name of the component (e.g. “Risk calculator”, “Audit component”, etc).
                • Technology: The technology choice for the component (e.g. Plain Old [Java|C#|Ruby|etc]
                Object, Enterprise JavaBean, Windows Communication Foundation service, etc).
                • Responsibilities: A very high-level statement of the component’s responsibilities (e.g.
                either important operation names or a brief sentence describing the responsibilities).

        Interactions
            To reiterate the same advice given for other types of diagram, it’s useful to annotate the
            interactions between components rather than simply having a diagram with a collection of
            boxes and ambiguous lines connecting them all together. Useful information to add the diagram includes:
                • The purpose of the interaction (e.g. “uses”, “persists trade data through”, etc)
                • Communication style (e.g. synchronous, asynchronous, batched, two-phase commit, etc)

        Motivation
            Decomposing your software system into a number of components is software design at a slightly
            higher level of abstraction than classes and the code itself.

!!!         Working at this level is an excellent way to understand how your
            system will be internally structured, where reuse opportunities can be realised, where you have
            dependencies between components, where you have dependencies between components and
            containers, and so on. Breaking down the overall problem into a number of separate parts also
            provides you with a basis to get started with some high-level estimation, which is great if you’ve
            ever been asked for ballpark estimates for a new project.

            This is useful because:
                • It shows the high-level decomposition of your software system into components with
                distinct responsibilities.
                • It shows where there are relationships and dependencies between components.
                • It provides a framework for high-level software development estimates and how the
                delivery can be broken down.

            Designing a software system at this level of abstraction is something that can be done in a number
            of hours or days rather than weeks or months. It also sets you up for designing/coding at the
            class and interface level without worrying about the overall high-level structure.

        Audience
            • Technical people within the software development team

        Example
            As illustrated by the container diagram, techtribes.je includes a standalone process that pulls in
            content from Twitter, GitHub and blogs. The following diagram shows the high-level internal
            structure of the content updater in terms of components.
                see "4 - Component diagram example.png"

            And here are the core components are mention in "5- Component diagram core components.png"


    Technology choices included or omitted?
        Make technology choices explicit
            Including technology choices on software architecture diagrams removes ambiguity, even if
            you’re working in an environment where all software is built using a standard set of technologies
            and patterns. Imagine that you’re designing a software system. Are you really doing this without
            thinking about how you’re actually going to implement it? Are you really thinking in terms of
            conceptual boxes and functional decomposition? If the answer to these questions is “not really”,
            then why not add this additional layer of information onto the diagrams.

            Forcing people to include technology choices on their software architecture diagrams also tends
            to lead to much richer and deeper conversations that are grounded in the real-world

                • “how does this component communicate with that component if it’s running in separate process?”
                • “how does this component get initiated, and where does that responsibility sit?”
                • “why does this process need to communicate with that process?”
                • “why is this component going to be implemented in technology X rather than technology Y”


    Would you code it that way?
        Shared components
            Imagine that you’re designing a 3-tier software system that makes use of a web server, an
            application server and a database. While thinking about the high-level components that reside
            in each of these containers, it’s not uncommon to hear a conversation like this:
                • Attendee: “Should we draw the logging component outside of the web server and the
                application server, since it’s used by both?”
                • Me: “Would you code it that way? Will the logging component be running outside of both
                the web server and application server? For example, will it really be a separate standalone
                process?”
                • Attendee: “Well … no, it would probably be a shared component in a [JAR file|DLL|etc]
                that we would deploy to both servers.”
                • Me: “Great, then let’s draw it like that too. Include the logging component inside of each
                server and label it as a shared component with an annotation, stereotype or symbol.”

 !!!!       If in doubt, always ask yourself how you would code it.


    Software architecture vs code

        Responsibility-driven design and decomposition into components
            The Wikipedia page for "Component-based development" has a good summary and a “component” might be
            something like a risk calculator, audit logger, report generator, data importer, etc. The simplest
            way to think about a component is that it’s a set of related behaviours behind an interface,
            which may be implemented using one or more collaborating classes (assuming an OO language,
            of course). Good components share a number of characteristics with good classes. They should
            have high cohesion, low coupling, a well-defined public interface, good encapsulation, etc.

!!!         There are a number of benefits to thinking about a software system in terms of components,
            but essentially it allows us to think and talk about the software as a small number of high-level
            abstractions rather than the hundreds and thousands of individual classes that make up most
            enterprise systems.

        We talk about components but write classes
            People generally understand the benefit of thinking about software as a small number of highlevel building
            blocks. After all, it’s a great way to partition responsibilities across a software
            system and you’ll often hear people talking in terms of components when they’re having
            architecture discussions. This is what component-based development² is all about and although
            many people talk about their software systems in terms of components, that structure isn’t
            usually reflected in the code. This is one of the reasons why there is a disconnect between
            software architecture and coding as disciplines - the architecture diagrams on the wall say one
            thing, but the code says another.

            The mapping between the architectural view of a software system and the code are
            often very different. This is sometimes why you’ll see people ignore architecture diagrams (or
            documentation) and say “the code is the only single point of truth”.

            The organisation of the codebase can really help or hinder architectural understanding

!!!!    Packaging code by layer
            Many software teams structure their code by layer. In other words, if you open up a codebase,
            you’ll see a package for domain classes, one for UI stuff, one for “business services”, one for data
            access, another for integration points and so on. I’m using the Java terminology of a “package”
            here, but the same is applicable to namespaces in C#, etc.

            Although there’s nothing particularly wrong with packaging code in this way, this code structure
            never quite reflects the abstractions that we think about when we view the system from an
            architecture perspective. If you’re using an OO programming language, do you talk about
            “objects” when you’re having architecture discussions? In my experience, the answer is no. I
            typically hear people referring to concepts like components and services instead. The result is
            that a “component” on an architecture diagram is actually implemented by a combination of
            classes across a number of different layers. For example, you may find part of the component in
            a “services” package and the rest of the component inside the “data access” package.

            In order to make this possible, the code in the lower layers (e.g. that “data access” package)
            often has public visibility, which means that it can be called directly from any other layer in the
            architecture too.

        Packaging by feature
            Packaging by layer isn’t the only answer though and Mark Needham has a great blog post called
            Coding: Packaging by vertical slice⁴ that talks about another approach to code organisation based
            upon vertical slices of functionality

!!!!    Packaging by component
            A slight variation I like is organising code explicitly by component.

            This is similar to packaging by feature, but it’s more akin to the “micro services” that Mark
            Needham talks about in his blog post⁸. Each sub-package of je.techtribes.component⁹ houses
            a separate component, complete with it’s own internal layering and configuration. As far as
            possible, all of the internals are package scoped. You could potentially pull each component
            out and put it in it’s own project or source code repository to be versioned separately.

            Let’s be honest, organising code into packages isn’t something that gets a lot of braintime, particularly
            given the refactoring tools that we have at our disposal. Organising code by
            component lets you explicitly reflect the concept of “a component” from the architecture into the
            codebase. If your software architecture diagram screams something about your business domain
            (and it should), this will be reflected in your codebase too.

        Aligning software architecture and code
             Having a simple and explicit mapping from the architecture
            to the code can help even further, particularly when you start looking at collaborative design and
            collective code ownership. Furthermore, it helps bring software architecture firmly back into the
!!!         domain of the development team, which is ultimately where it belongs. Don’t forget though, the
            style of architecture you’re using needs to be reflected on your software architecture diagrams;
            whether that’s layers, components, micro-services or something else entirely


    You don’t need a UML tool
        There are many types of UML tool
            there are lots of commercial and open source tools that can help you to do software architecture and
            design, all tending to approach the problem from a different perspective. At a high-level, they can be
            categorised as follows.
                1. Diagrams only: There are many standalone UML tools and plug-ins for major IDEs that
                let you sketch simple UML diagrams. These are really useful if you want to be in control
                of your diagrams and what they portray but it’s easy for such diagrams to get out of date
                with reality over time. Microsoft Visio or OmniGraffle with UML templates installed are
                good starting points if you have access to them.
                2. Reverse engineering: There are standalone UML tools and IDE plug-ins that allow you
                to create UML diagrams from code. This is great because you can quickly get the code
                and diagrams in sync, but often these diagrams become cluttered quickly because they
                typically include all of the detail (e.g. every property, method and relationship) by default.
                3. Round-trip engineering: Many reverse engineering tools also allow you to do round-trip
                engineering, where changes made to the model are reflected in the code and vice versa.
                Again, this helps keeps code and diagrams in sync.
                4. Model-driven: There are a few model-driven architecture (MDA) tools that let you drive
                the implementation of a software system from the model itself, usually by annotating the
                diagrams with desired characteristics and behaviours using languages such as Executable
                UML (xUML) or Object Constraint Language (OCL). These tools can offer a full end-toend solution but you
                do need to follow a different and often rigid development process in order to benefit from them

        The simplest thing that could possibly work
!!!         The thing is though, you don’t need a UML tool in order to architect and design software. I’ve
            conducted a number of informal polls during my conference talks over the past few years and
            only 10-20% of the audience said that they regularly used UML in their day to day work. Often
            a blank sheet of paper, flip chart or whiteboard together with a set of sticky notes or index cards
            is all you need, particularly when you have a group of people who want to undertake the design
            process in a collaborative way. Have you ever tried to get three or four people collaborating
            around a laptop screen?

            Just remember that you need to explicitly
            think about things like traceability between levels of abstraction, conventions and consistency
            if you don’t use a tool. For example, UML arrows have meaning and without a key it might not
!!          be obvious whether your freehand arrows are pointing towards dependencies or showing the
            direction that data flows. You can always record your designs in a more formal way using a
            UML tool later if you need to do so.

        Uses for UML        (various types of diagrams depending on the needs)
            • Processes and workflows: If I’m building software that automates a process or is very
            workflow based, I’ll often draw a simple UML activity diagram to represent it
            • Runtime behaviour: My C4 approach is really only focussed on visualising the static
            structure of a software system, but often it’s useful to present the system from a runtime
            perspective. UML sequence and collaboration diagrams are usually used to show how a
            number of classes collaborate at runtime to implement a particular user story, use case,
            feature, etc
            • Domain model: I’ll use a UML class diagram if I want to visualise a domain model, with the
            resulting diagrams typically only showing the most important attributes and relationships.
            • State charts: UML state diagrams are a great way to visualise a state machine and the
            notation is fairly straightforward.
            • Deployment: A UML deployment diagram can be a useful way to show how your
            containers or components are deployed.

        If you’re unfamiliar with UML, perhaps now is a good opportunity to make yourself
        aware of the various diagrams that are available. You don’t need UML tools to do architecture
        and design, but they do have their uses. You don’t need to use every type of diagram though!


!!!!Effective sketches          (things to consider when doing NO UML diagrams..aka basic sketches on a whiteboard)
        The Unified Modelling Language (UML) is a formal, standardised notation for communicating
        the design of software systems although many people favour boxes and lines style sketches
        instead. There’s absolutely nothing wrong with this but you do trade-off diagram consistency
        for flexibility. The result is that many of these informal sketches use diagramming elements
        inconsistently and often need a narrative to accompany them.

        If you are going to use “NoUML” diagrams (i.e. anything that isn’t UML), here are some things to
        think about, both when you’re drawing sketches on a whiteboard and if you decide to formalise
        them in something like Microsoft Visio afterwards.

        Titles
            The first thing that can really help people to understand a diagram is including a title. If you’re
            using UML, the diagram elements will provide some information as to what the context of the
            diagram is, but that doesn’t really help if you have a collection of diagrams that are all just boxes
            and lines. Try to make the titles short and meaningful. If the diagrams should be read in a specific
            order, make sure this is clear by numbering them

        Labels
            You’re likely to have a number of labels on your diagrams; including names of software systems,
            components, etc. Where possible, avoid using acronyms and if you do need to use acronyms
            for brevity, ensure that they are documented in a project glossary or with a key somewhere on
            the diagram

            The exceptions here are acronyms used to describe technology choices, particularly if they
            are used widely across the industry. Examples include things like JMS (Java Message Service),
            POJO (plain old Java object)

        Shapes
            Most boxes and lines style sketches that I’ve seen aren’t just boxes and lines, with teams using
            a variety of shapes to represent elements within their software architecture. For example, you’ll
            often see cylinders on a diagram and many people will interpret them to be a database of some
            description. Make sure that you include an explanation to confirm whether this is the case or
            not.

        Responsibilities
            If naming is one of the hardest things in software development, resist the temptation to have a
            diagram full of boxes that only contain names. A really simple way to add an additional layer of
            information to, and remove any ambiguity from, an architecture diagram is to annotate things
            like systems and components with a very short statement of what their responsibilities are. A
            bulleted list (7 ± 2 items¹) or a short sentence work well.

                (see "6 - Responsabilities remove ambiguity.png" for example)

        Lines
            Lines are an important part of most architecture sketches, acting as the glue that holds all of the
            boxes (systems, containers, components, etc) together. The big problem with lines is exactly this
            though, they tend to be thought of as the things that hold the other, more significant elements
            of the diagram together and don’t get much focus themselves. Whenever you’re drawing lines
            on sketches, ensure you use them consistently and that they have a clear purpose. For example:
                • Line style (solid, dotted, dashed, etc): Is the line style relevant and, if so, what does it mean?
                • Arrows: Do arrows point in the direction of dependencies (e.g. like UML “uses” relationships) or do
                they indicate the direction in which data normally flows?

            Often annotations on the lines (e.g. “uses”, “sends data to”, “downloads report from”, etc) can
            help to clarify the direction in which arrows are pointing, but watch out for any lines that have
            arrows on both ends!

        Borders
            Adding borders (e.g. double lines, coloured lines, dashed lines, etc) around diagram elements
            can be a great way to add emphasis or to group related elements together. If you do this, make
            sure that it’s obvious what the border means, either by labelling the border or by including an
            explanation in the diagram key

!!!!!  Diagram review checklist
            The software architecture process is about introducing structure and vision into software
            projects, so when reviewing architecture diagrams, here are a number of things that you might
            want to assert to ensure that this is the case. This checklist is applicable for diagrams produced
            during the initial architecture process, as well as those produced to retrospectively document an
            existing software system.
            1. I can see and understand the solution from multiple levels of abstraction.
            2. I understand the big picture; including who is going to use the system (e.g. roles, personas,
            etc) and what the dependencies are on the existing IT environment (e.g. existing systems).
            3. I understand the logical containers and the high-level technology choices that have been
            made (e.g. web servers, databases, etc).
            4. I understand what the major components are and how they are used to satisfy the
            important user stories/use cases/features/etc.
            5. I understand what all of the components are, what their responsibilities are and can see
            that all components have a home.
            6. I understand the notation, conventions, colour coding, etc used on the diagrams.
            7. I can see the traceability between diagrams and diagramming elements have been used consistently.
            8. I understand what the business domain is and can see a high-level view of the functionality
            that the software system provides.
            9. I understand the implementation strategy (frameworks, libraries, APIs, etc) and can almost
            visualise how the system will be or has been implemented.

        Q&As
            Question: “If I have something like a logging component that is used by all of the other
            components, how should I show this on the diagrams?”
            Answer: You have a couple of options, although one tends to lead to much cleaner diagrams.
            Option 1 is to draw the logging component somewhere central on the diagram and show
            connections from every other component to it. While this is accurate, your diagram will become
            cluttered very quickly. Option 2 is to draw the logging component somewhere out of the way
            and simply annotate it with a note that says something like “this is a utility component that is
            used by all other components”.

            Question: “I like the C4 approach but it only focusses on one software system at a time. How
            can we show more than one software system?”
            Answer: In the real-world, software systems never live in isolation and it’s often useful to
            understand how all of the various software systems fit together within the bounds of an
            enterprise. To do this, I’ll simply add another diagram that sits on top of the C4 diagrams, to
            show the enterprise context from an IT perspective. C4 therefore becomes C5, with this extra
            diagram showing:
            • The organisational boundary.
            • Internal and external users.
            • Internal and external systems (including a high-level summary of their responsibilities and
            data owned).


===============================================================================================================
===============================================================================================================
Part 5 - Documenting software

    This part of the book is about that essential topic we love to hate - writing documentation!

    The code doesn’t tell the whole story

        Let’s imagine that you’ve started work on a new software project that’s already underway. The
        major building blocks are in place and some of the functionality has already been delivered. You
        start up your development machine, download the code from the source code control system
        and load it up into your development environment. What do you do next and how do you start
        being productive?

        If nobody has the time to walk you through the codebase, you can start to make your own
        assumptions based upon the limited knowledge you have about the project, the business domain,
        your expectations of how the team builds software and your knowledge of the technologies in
        use

    The code doesn’t portray the intent of the design
        A further deep-dive through the code will help to prove your initial assumptions right or wrong,
        but it’s also likely to leave you with a whole host of questions. Perhaps you understand what the
        system does at a high level, but you don’t understand things like:
            • How the software system fits into the existing system landscape.
            • Why the technologies in use were chosen.
            • The overall structure of the software system.
            • Where the various components are deployed at runtime and how they communicate.
            • How the web-tier “knows” where to find the middle-tier.
            • What approach to logging/configuration/error handling/etc has been adopted and whether
            it is consistent across the codebase.
            • Whether any common patterns and principles are in use across the codebase.
            • How and where to add new functionality.
            • How security has been implemented across the stack.
            • How scalability is achieved.
            • How the interfaces with other systems work.
            • etc


    Software documentation as a guidebook
        “Working software over comprehensive documentation” is what the Manifesto for Agile Software Development¹ says
        and it’s incredible to see how many software teams have interpreted those five words as “don’t write any
        documentation”.

        If the original software developers leave
        the consulting organisation, will the new team be able to understand what the software is all
        about, how it’s been built and how to enhance it in a way that is sympathetic to the original
        architecture? And what about the poor customer? Is it right that they should only be delivered
        a working codebase?

        The problem is that when software teams think about documentation, they usually think
        of huge Microsoft Word documents based upon a software architecture document template
        from the 1990’s that includes sections where they need to draw Unified Modeling Language
        (UML) class diagrams for every use case that their software supports. Few people enjoy
!!!     reading this type of document, let alone writing it! A different approach is needed. We should
        think about supplementary documentation as an ever-changing travel guidebook rather than a
        comprehensive static piece of history. But what goes into a such a guidebook?

        1. Maps
            Let’s imagine that I teleported you away from where you are now and dropped you in a quiet,
            leafy country lane somewhere in the world (picture 1). Where are you and how do you figure
            out the answer to this question?

            Diagrams can act as maps to help people navigate a complex codebase and this is one of the
            most important parts of supplementary software documentation. Ideally there should be a small
            number of simple diagrams, each showing a different part of the software system or level of
            abstraction. My C4 approach is how I summarise the static structure of a software system but
            there are others including the use of UML.

        2. Sights
            A codebase is no different. Although we could spend a long time diagramming and describing
            every single piece of code, there’s really little value in doing that. What we really need is
            something that lists out the points of interest so that we can focus our energy on understanding
            the major elements of the software without getting bogged down in all of the detail. Many web
            applications, for example, are actually fairly boring and rather than understanding how each
            of the 200+ pages work, I’d rather see the points of interest. These may include things like the
            patterns that are used to implement web pages and data access strategies along with how security
            and scalability are handled

        3. History and culture
            Again, a codebase is no different and some knowledge of the history, culture and rationale can
            go a long way in helping you understand why a software system has been designed in the way
            it was. This is particularly useful for people who are new to an existing team.

        4. Practical information
            If we think about a software system, the practical information might include where the source
            code can be found, how to build it, how to deploy it, the principles that the team follow, etc. It’s
            all of the stuff that can help the development team do their job effectively

        Keep it short, keep it simple
            The following headings describe what you might want to include in a software guidebook:
            1. Context
            2. Functional Overview
            3. Quality Attributes
            4. Constraints
            5. Principles
            6. Software Architecture
            7. External Interfaces
            8. Code
            9. Data
            10. Infrastructure Architecture
            11. Deployment
            12. Operation and Support
            13. Decision Log


!!! Context
        A context section should be one of the first sections of the software guidebook and simply used
        to set the scene for the remainder of the document.

        Intent
            A context section should answer the following types of questions:
            • What is this software project/product/system all about?
            • What is it that’s being built?
            • How does it fit into the existing environment? (e.g. systems, business processes, etc)
            • Who is using it? (users, roles, actors, personas, etc)

        Structure
            The context section doesn’t need to be long; a page or two is sufficient and a context diagram is
            a great way to tell most of the story

        Motivation
            I’ve seen software architecture documents that don’t start by setting the scene and, 30 pages
            in, you’re still none the wiser as to why the software exists and where it fits into the existing
            IT environment. A context section doesn’t take long to create but can be immensely useful,
            especially for those outside of the team.

        Audience
            Technical and non-technical people, inside and outside of the immediate software development team.

        Required
            Yes, all software guidebooks should include an initial context section to set the scene.


!!! Functional Overview
        Even though the purpose of a software guidebook isn’t to explain what the software does in
        detail, it can be useful to expand on the context and summarise what the major functions of the
        software are.

        Intent
            This section allows you to summarise what the key functions of the system are. It also allows
            you to make an explicit link between the functional aspects of the system (use cases, user stories,
            etc) and, if they are significant to the architecture, to explain why. A functional overview should
            answer the following types of questions:
            • Is it clear what the system actually does?
            • Is it clear which features, functions, use cases, user stories, etc are significant to the
            architecture and why?
            • Is it clear who the important users are (roles, actors, personas, etc) and how the system
            caters for their needs?
            • It is clear that the above has been used to shape and define the architecture?

        Structure
            By all means refer to existing documentation if it’s available; and by this I mean functional
            specifications, use case documents or even lists of user stories. However, it’s often useful to
            summarise the business domain and the functionality provided by the system. Again, diagrams
            can help, and you could use a UML use case diagram or a collection of simple wireframes showing
            the important parts of the user interface. Either way, remember that the purpose of this section
            is to provide an overview.

        Motivation
            Where a context section summarises how the software fits into the existing
            environment, this section describes what the system actually does. Again, this is about providing
            a summary and setting the scene rather than comprehensively describing every user/system
            interaction.

        Audience
            Technical and non-technical people, inside and outside of the immediate software development team.

        Required
            Yes, all software guidebooks should include a summary of the functionality provided by the software.


    Quality Attributes
        With the functional overview section summarising the functionality, it’s also worth including a
        separate section to summarise the quality attributes/non-functional requirements.

        Intent
            This section is about summarising the key quality attributes and should answer the following
            types of questions:
            • Is there a clear understanding of the quality attributes that the architecture must satisfy?
            • Are the quality attributes SMART (specific, measurable, achievable, relevant and timely)?
            • Have quality attributes that are usually taken for granted been explicitly marked as out
            of scope if they are not needed? (e.g. “user interface elements will only be presented in
            English” to indicate that multi-language support is not explicitly catered for)
            • Are any of the quality attributes unrealistic? (e.g. true 24x7 availability is typically very
            costly to implement inside many organisations)

        Structure
            Simply listing out each of the quality attributes is a good starting point. Examples include:
            • Performance (e.g. latency and throughput)
            • Scalability (e.g. data and traffic volumes)
            • Availability (e.g. uptime, downtime, scheduled maintenance, 24x7, 99.9%, etc)
            • Security (e.g. authentication, authorisation, data confidentiality, etc)
            • Extensibility
            • Flexibility
            • Auditing
            • Monitoring and management
            • Reliability
            • Failover/disaster recovery targets (e.g. manual vs automatic, how long will this take?)
            • Business continuity
            • Interoperability
            • Legal, compliance and regulatory requirements (e.g. data protection act)
            • Internationalisation (i18n) and localisation (L10n)
            • Accessibility
            • Usability

            Each quality attribute should be precise, leaving no interpretation to the reader. Examples where
            this isn’t the case include:
            • “the request must be serviced quickly”
            • “there should be no overhead”
            • “as fast as possible”
            • “as small as possible”
            • “as many customers as possible”

        Motivation
            Typically, quality attributes are not given to you on
            a plate and an amount of exploration and refinement is usually needed to come up with a list
            of them. Put simply, writing down the quality attributes removes any ambiguity both now and
            during maintenance/enhancement work in the future.

        Audience
            Since quality attributes are mostly technical in nature, this section is really targeted at technical
            people in the software development team.

        Required
            Yes, all software guidebooks should include a summary of the quality attributes/non-functional
            requirements as they usually shape the resulting software architecture in some way


    Constraints
        Software lives within the context of the real-world, and the real-world has constraints. This
        section allows you to state these constraints so it’s clear that you are working within them and
        obvious how they affect your architecture decisions.

        Intent
            Constraints are typically imposed upon you but they aren’t necessarily “bad”, as reducing the
            number of available options often makes your job designing software easier. This section allows
            you to explicitly summarise the constraints that you’re working within and the decisions that
            have already been made for you.

        Structure
            As with the quality attributes, simply listing the known constraints and briefly summarising
            them will work. Example constraints include:
            • Time, budget and resources.
            • Approved technology lists and technology constraints.
            • Target deployment platform.
            • Existing systems and integration standards.
            • Local standards (e.g. development, coding, etc).
            • Public standards (e.g. HTTP, SOAP, XML, XML Schema, WSDL, etc).
            • Standard protocols.
            • Standard message formats.
            • Size of the software development team.
            • Skill profile of the software development team.
            • Nature of the software being built (e.g. tactical or strategic).
            • Political constraints.
            • Use of internal intellectual property.
            • etc

        Motivation
            Constraints have the power to massively influence the architecture, particularly if they limit the
            technology that can be used to build the solution. Documenting them prevents you having to
            answer questions in the future about why you’ve seemingly made some odd decisions.

        Audience
            The audience for this section includes everybody involved with the software development
            process, since some constraints are technical and some aren’t.

        Required
            Yes, all software guidebooks should include a summary of the constraints as they usually shape
            the resulting software architecture in some way. It’s worth making these constraints explicit
            at all times, even in environments that have a very well known set of constraints (e.g. “all of
            our software is ASP.NET against a SQL Server database”) because constraints have a habit of
            changing over time.


    Principles
        The principles section allows you to summarise those principles that have been used (or you are
        using) to design and build the software.

        Structure
            If you have an existing set of software development principles (e.g. on a development wiki),
            by all means simply reference it. Otherwise, list out the principles that you are following and
            accompany each with a short explanation or link to further information. Example principles
            include:
            • Architectural layering strategy.
            • No business logic in views.
            • No database access in views.
            • Use of interfaces.
            • Always use an ORM.
            • Dependency injection.
            • The Hollywood principle (don’t call us, we’ll call you).
            • High cohesion, low coupling.
            • Follow SOLID¹ (Single responsibility principle, Open/closed principle, Liskov substitution
            principle, Interface segregation principle, Dependency inversion principle).
            • DRY (don’t repeat yourself).
            • Ensure all components are stateless (e.g. to ease scaling).
            • Prefer a rich domain model.
            • Prefer an anaemic domain model.
            • Always prefer stored procedures.
            • Never use stored procedures.
            • Don’t reinvent the wheel.
            • Common approaches for error handling, logging, etc.
            • Buy rather than build.

        Audience
            The audience for this section is predominantly the technical people in the software development
            team.
        Required
            Yes, all software guidebooks should include a summary of the principles that have been or are
            being used to develop the software.


    Software Architecture
        The software architecture section is your “big picture” view and allows you to present the
        structure of the software. Traditional software architecture documents typically refer to this
        as a “conceptual view” or “logical view”, and there is often confusion about whether such views
        should refer to implementation details such as technology choices.

        Intent
            The purpose of this section is to summarise the software architecture of your software system
            so that the following questions can be answered:
            • What does the “big picture” look like?
            • Is there are clear structure?
            • Is it clear how the system works from the “30,000 foot view”?
            • Does it show the major containers and technology choices?
            • Does it show the major components and their interactions?
            • What are the key internal interfaces? (e.g. a web service between your web and business tiers)

        Structure
            I use the container and component diagrams as the main focus for this section, accompanied by
            a short narrative explaining what the diagram is showing plus a summary of each container/-
            component.
            Sometimes UML sequence or collaboration diagrams showing component interactions can be a
            useful way to illustrate how the software satisfies the major use cases/user stories/etc. Only do
            this if it adds value though and resist the temptation to describe how every use case/user story
            works!
        Motivation
            The motivation for writing this section is that it provides the maps that people can use to get an
            overview of the software and help developers navigate the codebase.


    External Interfaces
        Interfaces, particularly those that are external to your software system, are one of the riskiest
        parts of any software system so it’s very useful to summarise what the interfaces are and how
        they work.

        Intent
            The purpose of this section is to answer the following types of questions:
            • What are the key external interfaces?
            – e.g. between your system and other systems (whether they are internal or external to your environment)
            – e.g. any APIs that you are exposing for consumption
            – e.g. any files that your are exporting from your system
            • Has each interface been thought about from a technical perspective?
            – What is the technical definition of the interface?
            – If messaging is being used, which queues (point-to-point) and topics (pub-sub) are
            components using to communicate?
            – What format are the messages (e.g. plain text or XML defined by a DTD/Schema)?
            – Are they synchronous or asynchronous?
            – Are asynchronous messaging links guaranteed?
            – Are subscribers durable where necessary?
            – Can messages be received out of order and is this a problem?
            – Are interfaces idempotent?
            – Is the interface always available or do you, for example, need to cache data locally?
            – How is performance/scalability/security/etc catered for?
            • Has each interface been thought about from a non-technical perspective?
            – Who has ownership of the interface?
            – How often does the interface change and how is versioning handled?
            – Are there any service-level agreements in place?

        Structure
            I tend to simply list out the interfaces (in the form “From X to Y”) along with a short narrative
            that describes the characteristics of the interface. To put the interfaces in context, I may include
            a simplified version of the container or component diagrams that emphasise the interfaces.

        Audience
            The audience for this section is predominantly the technical people in the software development
            team.

        Required
            No, I only include this section if I’m building something that has one or more complex interfaces.
            For example, I wouldn’t include it for a standard “web server -> database” style of software
            system, but I would include this section if that web application needed to communicate with an
            external system where it was consuming information via an API.


    Code
        Although other sections of the software guidebook describe the overall architecture of the
        software, often you’ll want to present lower level details to explain how things work. This is
        what the code section is for. Some software architecture documentation templates call this the
        “implementation view” or the “development view”.

        Intent
            The purpose of the code section is to describe the implementation details for parts of the software
            system that are important, complex, significant, etc. For example, I’ve written about the following
            for software projects that I’ve been involved in:
            • Generating/rendering HTML: a short description of an in-house framework that was
            created for generating HTML, including the major classes and concepts.
            • Data binding: our approach to updating business objects as the result of HTTP POST requests.
            • Multi-page data collection: a short description of an in-house framework we used for building forms that
            spanned multiple web pages.
            • Web MVC: an example usage of the web MVC framework that was being used.
            • Security: our approach to using Windows Identity Foundation (WIF) for authentication
            and authorisation.
            • Domain model: an overview of the important parts of the domain model.
            • Component framework: a short description of the framework that we built to allow
            components to be reconfigured at runtime.
            • Configuration: a short description of the standard component configuration mechanism
            in use across the codebase.
            • Architectural layering: an overview of the layering strategy and the patterns in use to implement it.
            • Exceptions and logging: a summary of our approach to exception handling and logging
            across the various architectural layers.
            • Patterns and principles: an explanation of how patterns and principles are implemented.

        Structure
            Keep it simple, with a short section for each element that you want to describe and include
            diagrams if they help the reader. For example, a high-level UML class and/or sequence diagram
            can be useful to help explain how a bespoke in-house framework works. R

        Motivation
            The motivation for writing this section is to ensure that everybody understands how the
            important/significant/complex parts of the software system work so that they can maintain,
            enhance and extend them in a consistent and coherent manner. This section also helps new
            members of the team get up to speed quickly


    Data
        The data associated with a software system is usually not the primary point of focus yet it’s
        arguably more important than the software itself, so often it’s useful to document something about it.

            Intent
                The purpose of the data section is to record anything that is important from a data perspective,
                answering the following types of questions:
                • What does the data model look like?
                • Where is data stored?
                • Who owns the data?
                • How much storage space is needed for the data? (e.g. especially if you’re dealing with “big
                data”)
                • What are the archiving and back-up strategies?
                • Are there any regulatory requirements for the long term archival of business data?
                • Likewise for log files and audit trails?
                • Are flat files being used for storage? If so, what format is being used?

            Structure
                Keep it simple, with a short section for each element that you want to describe and include
                domain models or entity relationship diagrams if they help the reader.


    Infrastructure Architecture
        While most of the software guidebook is focussed on the software itself, we do also need to
        consider the infrastructure because software architecture is about software and infrastructure.

        Intent
            This section is used to describe the physical/virtual hardware and networks on which the
            software will be deployed. Although, as a software architect, you may not be involved in
            designing the infrastructure, you do need to understand that it’s sufficient to enable you to satisfy
            your goals. The purpose of this section is to answer the following types of questions:
            • Is there a clear physical architecture?
            • What hardware (virtual or physical) does this include across all tiers?
            • Does it cater for redundancy, failover and disaster recovery if applicable?
            • Is it clear how the chosen hardware components have been sized and selected?
            • If multiple servers and sites are used, what are the network links between them?
            • Who is responsible for support and maintenance of the infrastructure?
            • Are there central teams to look after common infrastructure (e.g. databases, message buses,
            application servers, networks, routers, switches, load balancers, reverse proxies, internet
            connections, etc)?
            • Who owns the resources?
            • Are there sufficient environments for development, testing, acceptance, pre-production, production, etc?

        Structure
            The main focus for this section is usually an infrastructure/network diagram showing the various
            hardware/network components and how they fit together, with a short narrative to accompany
            the diagram

        Motivation
            The motivation for writing this section is to force me (the software architect) to step outside of
            my comfort zone and think about the infrastructure architecture. If I don’t understand it, there’s a
            chance that the software architecture I’m creating won’t work or that the existing infrastructure
            won’t support what I’m trying to do


    Deployment
        The deployment section is simply the mapping between the software and the infrastructure.

        Intent
            This section is used to describe the mapping between the software (e.g. containers) and the
            infrastructure. Sometimes this will be a simple one-to-one mapping (e.g. deploy a web application
            to a single web server) and at other times it will be more complex (e.g. deploy a web application
            across a number of servers in a server farm). This section answers the following types of
            questions:
            • How and where is the software installed and configured?
            • Is it clear how the software will be deployed across the infrastructure elements described
            in the infrastructure architecture section? (e.g. one-to-one mapping, multiple containers
            per server, etc)
            • If this is still to be decided, what are the options and have they been documented?
            • Is it understood how memory and CPU will be partitioned between the processes running
            on a single piece of infrastructure?
            • Are any containers and/or components running in an active-active, active-passive, hotstandby, cold-standby,
             etc formation?
            • Has the deployment and rollback strategy been defined?

        Structure
            There are a few ways to structure this section:
            1. Tables: simple textual tables that show the mapping between software containers and/or
            components with the infrastructure they will be deployed on.
            2. Diagrams: UML deployment diagrams or modified versions of the diagrams from the
            infrastructure architecture section showing where software will be running

        Audience
            The audience for this section is predominantly the technical people in the software development
            team along with others that may help deploy, support and operate the software system.
        Required
            Yes, a deployment section should be included in all software guidebooks because it can he


    Operation and Support
        The operations and support section allows you to describe how people will run, monitor and
        manage your software.

        Intent
            Most systems will be subject to support and operational requirements, particularly around how
            they are monitored, managed and administered. Including a dedicated section in the software
            guidebook lets you be explicit about how your software will or does support those requirements.
            This section should address the following types of questions:
            • Is it clear how the software provides the ability for operation/support teams to monitor
            and manage the system?
            • How is this achieved across all tiers of the architecture?
            • How can operational staff diagnose problems?
            • Where are errors and information logged? (e.g. log files, Windows Event Log, SMNP, JMX,
            WMI, custom diagnostics, etc)
            • Do configuration changes require a restart?
            • Are there any manual housekeeping tasks that need to be performed on a regular basis?
            • Does old data need to be periodically archived?

        Structure
            This section is usually fairly narrative in nature, with a heading for each related set of
            information (e.g. monitoring, diagnostics, configuration, etc).

        Required
            Yes, an operations and support section should be included in all software guidebooks, unless you
            like throwing software into a black hole and hoping for the best!


    Decision Log
        The final thing you might consider including in a software guidebook is a log of the decisions
        that have been made during the development of the software system.

        Intent
            The purpose of this section is to simply record the major decisions that have been made, including
            both the technology choices (e.g. products, frameworks, etc) and the overall architecture (e.g. the
            structure of the software, architectural style, decomposition, patterns, etc). For example:
            • Why did you choose technology or framework “X” over “Y” and “Z”?
            • How did you do this? Product evaluation or proof of concept?
            • Were you forced into making a decision about “X” based upon corporate policy or
            enterprise architecture strategies?
            • Why did you choose the selected software architecture? What other options did you
            consider?
            • How do you know that the solution satisfies the major non-functional requirements?
            • etc

        Structure
            Again, keep it simple, with a short paragraph describing each decision that you want to record.
            Do refer to other resources such as proof of concepts, performance testing results or product
            evaluations if you have them.

        Motivation
            The motivation for recording the significant decisions is that this section can act as a point
            of reference in the future. All decisions are made given a specific context and usually have
            trade-offs. There is usually never a perfect solution to a given problem. Articulating the decision
            making process after the event is often complex, particularly if you’re explaining the decision to
            people who are joining the team or you’re in an environment where the context changes on a
            regular basis.
            Although “nobody ever gets fired for buying IBM”, perhaps writing down the fact that corporate
            policy forced you into using IBM WebSphere over Apache Tomcat will save you some tricky
            conversations in the future.


===============================================================================================================
===============================================================================================================
Part 6 - Software architecture in the development life cycle

    This, the final part of the book, is about how everything else covered in the book fits into the dayto-day world of
    software development. We’ll also answer the question of how much software architecture (and therefore, up front
    design) you should do.


    The conflict between agile and architecture - myth or reality?

        Architecture can be summarised as being about structure and vision, with a key part of the
        process focussed on understanding the significant design decisions. Unless you’re running the
        leanest of startups and you genuinely don’t know which direction you’re heading in, even the
        most agile of software projects will have some architectural concerns and these things really
        should be thought about up front. Agile software projects therefore do need “architecture”, but
        this seems to contradict with how agile has been evangelised for the past 10+ years. Put simply,
        there is no conflict between agile and architecture because agile projects need architecture.

        Conflict 1: Team structure
            Indeed, because of the way in
            which agile approaches have been evangelised, there is often a perception that agile teams must
            consist of cross-discipline team members and simply left to self-organise. The result? Many agile
            teams will tell you that they “don’t need no stinkin’ architects”!

        Conflict 2: Process and outputs
            One of the key goals of agile approaches is to deliver customer value, frequently and in small chunks.
            It’s about moving fast, getting feedback and embracing change. The goal of big design up front is
            to settle on an understanding of everything that needs to be delivered before putting a blueprint
            (and usually a plan) in place.

            The result is that in trying to avoid big up front design, agile
            teams often do no design up front and instead use terms like “emergent design” or “evolutionary
            architecture” to justify their approach. I’ve even heard teams claim that their adoption of testdriven
            development (TDD) negates the need for “architecture”, but these are often the same
            teams that get trapped in a constant refactoring cycle at some point in the future.


!!! Quantifying risk
        Identifying risks is a crucial part of doing “just enough up front design” and, put simply, a risk
        is something bad that may happen in the future, such as a chosen technology not being able to
        fulfil the promises that the vendor makes. Not all risks are created equal though, with some being
        more important than others. For example, a risk that may make your software project fail should
        be treated as a higher priority than something that may cause the team some general discomfort.

        Assuming that you have a list of risks (and risk-storming is a great technique for doing this),
        how do you quantify each of those risks and assess their relative priorities? There are a number
        of well established approaches to quantifying risk; including assigning a value of low, medium
        or high or even a simple numeric value between 1 and 10, with higher numbers representing
        higher levels of risk.

        Probability vs impact
            A good way to think about risk is to separate out the probability of that risk happening from the
            negative impact of it happening.

            • Probability: How likely is it that the risk will happen? Do you think that the chance is
            remote or would you be willing to bet cash on it?
            • Impact: What is the negative impact if the risk does occur? Is there general discomfort for
            the team or is it back to the drawing board? Or will it cause your software project to fail?


!!!!                            (Dan: this entire part is important)
    Risk-storming
        Risk identification is a crucial part of doing “just enough up front design” but it’s something that
        many software teams shy away from because it’s often seen as a boring chore. Risk-storming is
        a quick, fun, collaborative and visual technique for identifying risk that the whole team can take
        part in. There are 4 step

        Step 1. Draw some architecture diagrams
            The first step is to draw some architecture diagrams on whiteboards or large sheets of flip chart
            paper. C4 is a good starting point because it provides a way to have a collection of diagrams at
            different levels of abstraction, some of which will allow you to highlight different risks across
            your architecture. Large diagrams are better

        Step 2. Identify the risks individually
            Risks can be subjective, so ask everybody on the team (architects, developers, project managers,
            operational staff, etc) to stand in front of the architecture diagrams and individually write down
            the risks that they can identify, one per sticky note. Additionally, ask people to quantify each risk
            based upon probability and impact. Ideally, use different colours of sticky note to represent the
            different risk priorities. You can timebox this part of the exercise to 5-10 minutes to ensure that
            it doesn’t drag on and this step should be done in silence, with everybody keeping their sticky
            notes hidden. Here are some examples of the risks to look for:
            • Data formats from third-party systems change unexpectedly.
            • External systems become unavailable.
            • Components run too slowly.
            • Components don’t scale.
            • Key components crash.
            • Single points of failure.
            • Data becomes corrupted.
            • Infrastructure fails.
            • Disks fill up.
            • New technology doesn’t work as expected.
            • New technology is too complex to work with.

        Step 3. Converge the risks on the diagrams
            Next, ask everybody to place their sticky notes onto the architecture diagrams, sticking them
            in close proximity to the area where the risk has been identified. For example, if you identify
            a risk that one of your components will run too slowly, put the sticky note over the top of that
            component on the architecture diagram.

        Step 4. Prioritise the risks
            Now you can take each sticky note (or cluster of sticky notes) and agree on how you will
            collectively quantify the risk that has been identified.
                • Individual sticky notes: Ask the person who identified the risk what their reason was and
                collectively agree on the probability and impact. After discussion, if either the probability
                or impact turns out to be “none”, take the sticky note off of the architecture diagram but
                don’t throw it away just yet.
                • Clusters of sticky notes: If the probability and impact are the same on each sticky
                note, you’re done. If they aren’t, you’ll need to collectively agree on how to quantify
                the risk in the same way that you agree upon estimates during a Planning Poker¹ or
                Wideband Delphi² session. Look at the outliers and understand the rationale behind people
                quantifying the risk accordingly.

        Mitigation strategies
            Identifying the risks associated with your software architecture is an essential exercise but you
            also need to come up with mitigation strategies, either to prevent the risks from happening in the
            first place or to take corrective action if the risk does happen. Since the risks are now prioritised,
            you can focus on the highest priority ones first.
            There are a number of mitigation strategies the are applicable depending upon the type of risk,
            including:
                1. Education: Training the team, restructuring it or hiring new team members in areas where
                you lack experience (e.g. with new technology).
                2. Prototypes: Creating prototypes where they are needed to mitigate technical risks by
                proving that something does or doesn’t work. Since risk-storming is a visual technique, it
                lets you easily see the stripes through your software system that you should perhaps look
                at in more detail with prototypes.
                3. Rework: Changing your software architecture to remove or reduce the probability/impact
                of identified risks (e.g. removing single points of failure, adding a cache to protect from
                third-party system outages, etc). If you do decide to change your architecture, you can
                re-run the risk-storming exercise to check whether the change has had the desired effect.


     Just enough up front design
     You need to do “just enough”
         My approach to up front architecture and design is that you need to do “just enough”. If you
         say this to people they either think it’s an inspirational breath of fresh air that fits in with all of
         their existing beliefs or they think it’s a complete cop out! “Just enough” works as a guideline
         but it’s vague and doesn’t do much to help people assess how much is enough. Based upon my
         definition of architecture, you could say that you need to do just enough up front design to give
         you structure and vision. In other words, do enough so that you know what your goal is and
         how you’re going to achieve it. This is a better guideline, but it still doesn’t provide any concrete
         advice.

        How much up front design is too little?
            • No understanding of what and where the system boundary is.
            • No common understanding of “the big picture” within the team.
            • Inability to communicate the overall vision.
            • Team members aren’t clear or comfortable with what they need to do.
            • No thought about non-functional requirements/quality attributes.
            • No thought about how the constraints of the (real-world) environment affect the software
            (e.g. deployment environment).
            • No thoughts on key areas of risk; such as non-functional requirements, external interfaces, etc.
            • The significant problems and/or their answers haven’t been identified.
            • No thought on separation of concerns, appropriate levels of abstraction, layering, modifiability, flex points, etc.
            • No common understanding of the role that the architect(s) will play.
            • Inconsistent approaches to solving problems.
            • A lack of control and guidance for the team.
            • Significant change to the architecture during the project lifecycle that could have been anticipated.
            • Too many design alternatives and options, often with team members disagreeing on the
            solution or way forward.

        How much up front design is too much?
            • Too much information (i.e. long documents and/or information overload).
            • A design that is too detailed at too many levels of abstraction.
            • Too many diagrams.
            • Writing code or pseudo-code in documentation.
            • An architecture that is too rigid with no flexibility.
            • All decisions at all levels of abstraction have been made.
            • Class level design with numerous sequence diagrams showing all possible interactions.
            • Detailed entity relationship models and database designs (e.g. tables, views, stored procedures and indexes).
            • Analysis paralysis and a team that is stuck focussing on minor details.
            • Coding becomes a simple transformation of design artefacts to code, which is boring and
            demotivating for the team.
            • An unbounded “design phase” (i.e. time and/or budget).
            • The deadline has been reached without any coding.

!!!!!    Contextualising just enough up front design
            In reality, the “how much up front design is enough?” question must be answered by you and
            here’s my advice … go and practice architecting a software system. Find or create a small-medium
            size software project scenario and draft a very short set of high-level requirements (functional
            and non-functional) to describe it. This could be an existing system that you’ve worked on or
            something new and unrelated to your domain such as the financial risk system that I use on
            my training course. With this in place, ask two or more groups of 2-3 people to come up with
            a solution by choosing some technology, doing some design and drawing some diagrams to
            communicate the vision. Timebox the activity (e.g. 90 minutes) and then hold an open review
            session where the following types of questions are asked about each of the solutions:
                • Will the architecture work? If not, why not?
                • Have all of the key risks been identified?
                • Is the architecture too simple? Is it too complex?
                • Has the architecture been communicated effectively?
                • What do people like about the diagrams? What can be improved?
                • Is there too much detail? Is there enough detail?
                • Could you give this to your team as a starting point?
                • Is there too much control? Is there not enough guidance?
                • Are you happy with the level of technology decisions that have been made or deferred?

            Think of this exercise as an architectural kata⁵ except that you perform a review that focusses
            additionally on the process you went through and the outputs rather than just the architecture itself.

            Capture your findings and try to distill them into a set of guidelines for how to approach
            the software design process in the future. Agree upon and include examples of how much detail
            to go down into, agree on diagram notation and include examples of good diagrams, determine
            the common constraints within your own environment, etc. If possible, run the exercise again
            with the guidelines in mind to see how it changes things. One day is typically enough time to
            run through this exercise with a couple of design/communicate/review cycles.

!!!!
    Introducing software architecture
        I’ve met thousands of software developers from around the world and, in my experience, there’s
        a large number of them that don’t think about software architecture as much as they should.
        Despite the volume of educational material out there, teams lack knowledge about what software
        architecture really is

        This lack of understanding is made worse because most software developers don’t
        get to practice architecting software on a regular basis. How many software systems have you
        architected during your own career?

        Some practical suggestions
            Here are some practical suggestions for introducing software architecture.
                1. Educate people
                    Simply run some workshops where people can learn about and understand what software
                    architecture is all about. This can be aimed at developers or non-developers, and it will help
                    to make sure that everybody is talking the same language. At a minimum, you should look to cover:
                        • What software architecture is.
                        • Why software architecture is important.
                        • The practices you want to adopt.

                2. Talk about architecture in retrospectives
                    If you have regular retrospectives to reflect on how your team is performing, why not simply
                    include software architecture on the list of topics that you talk about? If you don’t think that
                    enough consideration is being given to software architecture, perhaps because you’re constantly
                    refactoring the architecture of your software or you’re having issues with some non-functional
                    characteristics, then think about the software architecture practices that you can adopt to help.
                    On the flip side, if you’re spending too much time thinking about software architecture or up
                    front design, perhaps it’s time to look at the value of this work and whether any practices can
                    be dropped or substituted.

                3. Definition of done
                    If you have a “definition of done” for work items, add software architecture to the list. This will
                    help ensure that you consider architectural implications of the work item and conformance of
                    the implementation with any desired architectural patterns/rules or non-functional goals.

                4. Allocate the software architecture role to somebody
                    If you have a software team that doesn’t think about software architecture, simply allocating
                    the software architecture role to somebody appropriate on the team may kickstart this because
                    you’re explicitly giving ownership and responsibility for the software architecture to somebody.
                    Allocating the role to more than one person does work with some teams, but I find it better that
                    one person takes ownership initially, with a view to sharing it with others as the team gains
                    more experience. Some teams dislike the term “software architect” and use the term architecture
                    owner³ instead. Whatever you call it, coaching and collaboration are key.

                5. Architecture katas
                    Words alone are not enough and the skeptics need to see that architecture is not about big design
                    up front. This is why I run short architecture katas where small teams collaboratively architect a
                    software solution for a simple set of requirements, producing one or more diagrams to visualise
                    and communicate their solutions to others. This allows people to experience that up front design
                    doesn’t necessarily mean designing everything to a very low level of abstraction and it provides
                    a way to practice communicating software architecture



===============================================================================================================
===============================================================================================================
Part 8 - Appendix B: Software Guidebook for techtribes.je

    This is a sample software guidebook for the techtribes.je¹ website, which is a side-project of mine
    to provide a focal point for the tech, IT and digital sector in Jersey.
    The code behind the techtribes.je website has been open sourced and is available on GitHub².

        (so if you ever need an example of a Software Guidebook...you have a good starting point in this chapter..)


TODO Add readme with the most important points from the book